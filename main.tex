% Nejprve uvedeme tridu dokumentu s volbami
\documentclass[czech,bachelor,public,dept460,male,oneside]{diploma}
\usepackage{subfig}		% makra pro "podobrazky" a "podtabulky"
\usepackage{amssymb}
\usepackage{pifont}
\usepackage{hyperref}
\usepackage{float}
\usepackage{titlesec}
\usepackage[linesnumbered,lined,commentsnumbered]{algorithm2e}

\setcounter{secnumdepth}{4}

\titleformat{\paragraph}
{\normalfont\normalsize\bfseries}{\theparagraph}{1em}{}
\titlespacing*{\paragraph}
{0pt}{3.25ex plus 1ex minus .2ex}{1.5ex plus .2ex}

\newcommand{\xmark}{\ding{55}}
\newcommand{\cmark}{\ding{51}}

\newcommand{\addfig}[3]{
	\begin{figure}[!h]
		\centering
		\includegraphics[width=#2\textwidth]{Figures/#1}
		\caption{#3}
	\end{figure}
}

\ThesisAuthor{Radek Svoboda}

\CzechThesisTitle{Nástroj pro modelování relační databáze}

\EnglishThesisTitle{Relational Database Modeling Tool}

\SubmissionDate{28. dubna 2017}

\Thanks{Rád bych na tomto místě poděkoval vedoucímu mé bakalářské práce Ing. Petru Lukášovi za poskytnuté rady a čas strávený konzultacemi.}

\ThesisAssignmentImagePath{Figures/Assignment}

% Zadame soubor s digitalizovanou podobou prohlaseni autora zaverecne prace.
% Pokud toto makro zapoznamkujeme sazi se cisty text prohlaseni.

% TODO: Podpis naskenovat a pak vymenit
%\AuthorDeclarationImageFile{Figures/AuthorDeclaration.jpg}


\CzechAbstract{Tato bakalářská práce se zabývá návrhem a implementací softwarového nástroje pro návrh schématu relační databáze formou ER diagramu. Nástroj umožní uživateli nejen tvorbu nových schémat databáze, ale také vizualizaci již existujících schémat a jejich následné modifikace prostřednictvím změn ER diagramu v grafickém editoru. V první části se práce zabývá notací ER diagramu a srovnáním již existujících nástrojů určených k tvorbě ER diagramů. Druhá část se zaměřuje na návrh a implementaci jak grafického editoru, tak na problematiku synchronizace ER diagramu s existujícím relačním schématem.}

\CzechKeywords{relační databáze, ER diagram, relační schéma, CASE nástroj}

\EnglishAbstract{This thesis describes design and implementation of software tool for relational database schema design in form of an ER diagram. Tool is not limited only for creation of new database schemas, but it also provides visualization of already existing schemas and their subsequent modifications through changing ER diagram in graphic editor. The first part deals with ER diagram notation and the comparison of existing tools for the creation of ER diagrams. The second part focuses on the design and implementation of both the graphical editor, and on the synchronization of ER diagram with existing relational schema.}

\EnglishKeywords{relational database, ER diagram, relational schema, CASE tool}

% \AddAcronym{DBMS}{Database Management System}

\AddAcronym{SQL}{Structured Query Language}
\AddAcronym{DDL}{Data Definition Language}
\AddAcronym{DML}{Data Manipulation Language}
\AddAcronym{CASE}{Computer-Aided Software Engineering}
\AddAcronym{ERD}{Entity-Relationship Diagram}
\AddAcronym{SŘBD}{Systém Řízení Báze Dat}
\AddAcronym{DSD}{Data Structure Diagram}
\AddAcronym{EER}{Enhanced Entity–Relationship Model}
\AddAcronym{IDEF}{Integration Definition for Information Modeling}
\AddAcronym{ICAM}{Integrated Computer-Aided Manufacturing}
\AddAcronym{JSON}{JavaScript Object Notation}
\AddAcronym{XML}{Extensible Markup Language}
\AddAcronym{CSV}{Comma-Separated Values}
\AddAcronym{PDF}{Portable Document Format}
\AddAcronym{PNG}{Portable Network Graphics}
\AddAcronym{JDBC}{Java Database Connectivity}
\AddAcronym{JPEG}{Joint Photographic Experts Group}
\AddAcronym{GUI}{Graphical User Interface}
\AddAcronym{WPF}{Windows Presentation Foundation}
\AddAcronym{MVVM}{Model-View-ViewModel}
\AddAcronym{MVC}{Model-View-Controller}
\AddAcronym{XAML}{Extensible Application Markup Language}
\AddAcronym{BFS}{Breadth-First Search}
\AddAcronym{XPS}{XML Paper Specification}

\begin{document}

\MakeTitlePages

% Pokud mame v zaverecne praci vypisy kodu, jinak odstranit.
\lstlistoflistings

\section{Úvod}
Strukturované uložení dat je jednou ze základních potřeb většiny vyvíjených aplikací. S~rostoucím množstvím uchovávaných dat a potřebou jejich analýzy už dávno není dostačující prosté uložení do souboru. Na tyto potřeby reagují dnes ve velké míře používané relační databáze. Před samotným uložením dat je nutné definovat jejich strukturu, tedy datový model. Dnešní svět se velmi rychle mění a tyto změny často vyvolají potřebu upravit datový model tak, aby co nejlépe reflektoval modelovanou realitu. Právě pro tuto činnost jsou dnes stále častěji používané CASE~nástroje, které umožňují snadnou změnu datového modelu prostřednictvím grafického uživatelského rozhraní bez nutnosti psaní vlastních DDL skriptů.

Tato bakalářská práce popisuje návrh a implementaci aplikace pro návrh a aktualizaci schématu relační databáze. Aplikace podporuje SŘBD Microsoft SQL~Server a Oracle~Database. První kapitola věnována popisu notace ER diagramu, který se v relačním schématu používá pro vizualizaci entit a vztahů mezi nimi nejčastěji. Kapitola 2 se zaměřuje na srovnání možností již existujících nástrojů pro tvorbu ER diagramu. Následuje kapitola 3, kde je popsán návrh a implementace grafického editoru ER diagramu, včetně algoritmů pro vyhledávání cest při vizualizaci vztahů. Poslední kapitola se zabývá synchronizací mezi ER diagramem a~relačním schématem, zejména spoluprací použitých návrhových vzorů pro dosažení požadované funkcionality pro oba dříve zmíněné SŘBD.

% Zdroje:
\section{Popis notace ER diagramu}
V kontextu relačních databází jsou ER diagramy nejběžnějším způsobem vizualizace entit a jejich vzájemných vztahů. V průběhu let vznikla celá řada notací, které se liší nejen použitými grafickými symboly pro znázornění entit, kardinality a povinnosti vztahů, ale i dalšími vlastnostmi \cite{compErNotations}. Dodnes nepředstavuje žádná z notací standard v oblasti modelování databází, což je nejvíce patrné na celé řadě CASE nástrojů, které často používají svou vlastní notaci či dokonce kombinaci symbolů z několika různých notací.

	\subsection{Historie}
	Za předchůdce ER diagramu jsou považovány diagramy datových struktur (DSD) \cite{bachmanDsd}, které rovněž slouží k zachycení entit a vztahů mezi nimi včetně vztažených omezení. Cílem DSD je graficky znázornit dekompozici složitých entit na jednotlivé elementy. K zachycení struktury dat se předpokládalo použití tzv. datových slovníků, které se dají zjednodušeně popsat jako množiny tabulek obsahující metadata. Z tohoto principu vychází i systémové katalogy moderních SŘBD.
	
	\begin{figure}[!h]
		\centering
		\includegraphics[width=0.75\textwidth]{Figures/BachmanDiagram}
		\caption[Bachmanův diagram]{Bachmanův diagram (Zdroj: \cite{wikiDsd})}
		\label{fig:bachmanDiag}
	\end{figure}
	
	Speciálním typem DSD je Bachmanův diagram, který slouží k vytvoření relačního datového modelu bez ohledu na způsob fyzického uložení dat v systému. Ukázku tohoto diagramu vidíme na obrázku \ref{fig:bachmanDiag}, který zachycuje vztah mezi zákazníky (customer) a objednávkami (order). Tento diagram měl patrně největší vliv na pozdější vznik ER diagramu, který publikoval Peter Chen roku 1976 \cite{chenERD}.
	Největším rozdílem mezi DSD a ERD, opomineme-li grafickou podobu, je fakt, že DSD se zaměřuje na popis struktury složitých entitních typů a vztahy modeluje na úrovni jednotlivých složek entitních typů, zatímco ERD řeší vztahy mezi samotnými entitními typy. 
		
	\subsection{Využití ER diagramu}
	Nejčastější použití ER diagramů představuje tvorba nových relačních schémat při návrhu databází. Rozhodně se ale nejedná o jedinou oblast využití. ER diagram velmi často stojí na počátku analýzy a návrhu mnoha informačních systémů využívajících relační databázi. Časté je i využití ER diagramu ve spojitosti s diagramy datových toků pro znázornění uložení dat business procesu. Diagramy můžeme dělit do více kategorií, viz kapitola \ref{secModelCategory}.
	
	Dalším velmi častým použitím ER diagramu je vizualizace již existujících schémat databáze, protože právě grafické znázornění schématu je ideální pro snadné odhalení logických chyb, ke kterým mohlo v rámci návrhu systému dojít.
	Vizualizace existujících schémat nemusí být použita pouze pro odhalení chyb, ale také při situaci, kdy je nutné datový model z různých důvodů upravit. ER diagram je tedy vhodný prostředek nejen k analýze stávajícího schématu pro návrh změn, ale také pro jejich přímé provádění prostřednictvím CASE nástrojů.
	
	\subsection{Kategorie modelů} \label{secModelCategory}
	Podle úrovně abstrakce rozlišujeme tři kategorie datových modelů \cite{whatIsERD}, které využíváme při návrhu databázového schématu. Nejvyšší úroveň abstrakce nabízí \emph{konceptuální model}, který zachycuje pouze entity a vztahy mezi nimi a je nejméně detailní. Konceptuální model není závislý na použitém SŘBD. Více detailů nabízí \emph{logický model}, poskytuje nižší úroveň abstrakce, ale stále je nezávislý na použitém SŘBD. Posledním typem je \emph{fyzický model}, ten vychází z logického modelu, nicméně se od něj může v mnoha ohledech lišit, protože jeho cílem je obsáhnout dostatečný počet technických detailů pro implementaci databáze. Rozdíly mezi logickým a fyzickým modelem způsobuje fakt, že fyzický model je vytvářen s ohledem na konkrétní použitou technologii. Proto i v případě, že zvolíme relační databázi, se mohou pro různé SŘBD fyzické modely více či méně lišit. Přehledné shrnutí rozdílů mezi modely nabízí tabulka \ref{tab:modelTypes} (znak \cmark značí, že daná položka je součástí modelu).
	
	\begin{table}[!h]
		\centering
		\caption{Rozdíly mezi modely}
		\label{tab:modelTypes}
		\begin{tabular}{l c c c}
			\toprule
			Modelované vlastnosti & Konceptuální & Logický & Fyzický \\
			\midrule
			Názvy entit & \cmark & \cmark & \xmark \\
			Vztahy & \cmark& \cmark & \xmark \\
			Atributy & \cmark& \cmark & \xmark \\
			Primární klíče & \xmark & \cmark & \cmark \\
			Cizí klíče & \xmark & \cmark & \cmark \\
			Názvy tabulek & \xmark & \xmark & \cmark \\
			Názvy sloupců & \xmark & \xmark & \cmark \\
			Datové typy sloupců & \xmark & \xmark & \cmark \\
			\midrule
		\end{tabular}
	\end{table}
	
	\subsection{Vývoj notací}
	Stejně, jako se vyvíjely potřeby návrhu datových modelů, vznikaly i nové notace ER diagramu. Zásadním mezníkem pro vývoj notací byl objektově orientovaný přístup k vývoji softwaru, na který se mnohé notace snažily reagovat. Tento trend způsobil rozšíření notací ER diagramu o~koncept generalizace/specializace a dědičnosti, tento typ modelu se označuje jako \emph{Enhanced entity–relationship model} (EER). Vlivem popularity objektově-relačních databází jsou některé notace často modifikovány tak, aby umožňovaly zahrnout v modelu metody a operace entit. Tento přístup je dnes k vidění v celé řadě CASE nástrojů a je vhodný zejména pro modelování komplexních databází pro geografické informační systémy nebo telekomunikace.
	
	\subsection{Vlastnosti notací}
	Na první pohled mohou různé notace vyvolávat dojem, že nejvýraznějším rozdílem mezi nimi je grafické znázornění entit a vztahů, nicméně rozdílů je mnohem více a některé mohou mít vliv na výslednou podobu fyzického modelu databáze.
		
		\subsubsection{Binární a \textit{n}-ární modely}
		Nejzásadnějším rozdílem mezi notacemi je podpora \textit{n}-árních modelů. Z toho důvodů rozlišujeme dva typy modelů: binární a \textit{n}-ární \cite{compErNotations}. Pro kategorii binárních modelů je typické, že každý objekt, který má alespoň jeden atribut, je považován za entitu. Není tedy možné přiřadit atribut vztahu, jak to můžeme běžně vidět u Chenovy notace. Tento fakt je nejvíce patrný u vztahu M:N, kterému chceme přiřadit atribut pro zaznamenání dalších informací. Přidání neklíčového atributu způsobí nutnost přidat do modelu asociační entitu pro tento vztah. 
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.55\textwidth]{Figures/TernaryRelationship2}
			\caption{Příklad ternárního vztahu}
			\label{fig:ternaryEx}
		\end{figure}
		
		Modely umožňující \textit{n}-ární vztahy mohou určité situace popisovat výstižněji než jejich rozklad na vztahy binární. V případě \textit{n}-árních modelů není nutné vytvářet další entity k přidání atributů pro vztah. Při přechodu na modely nabízející nižší úroveň abstrakce, je nutné \textit{n}-ární vztahy převést na sekvenci binárních vztahů, což může vést ke ztrátě cenných informací, protože už pro ternární vztah M:N:P může způsobů dekompozice existovat více a na první pohled nemusí být ztráta části informace patrná. Na obrázku~\ref{fig:ternaryEx} vidíme diagram modelující situaci, kdy učitel doporučuje knihy třídám, nicméně převod na sekvenci binárních vztahů může znemožnit zjištění informací o tom, kdo z učitelů doporučil danou knihu.
		
%		Podpora \textit{n}-árních vztahů vede k nekompatibilitě mezi jednotlivými notacemi, kdy nemusí být snadné převést model používající jednu notaci na model jiné notace. Z tohoto důvodu dnešní CASE nástroje obvykle podporují pouze jeden typ notace, případně typů podporují více, ale pouze ze stejné kategorie s ohledem na podporu arity vztahů. 
		
		\subsubsection{Kardinalita a povinnost}
		Vyjádření kardinality a povinnosti vztahu je další z mnoha odlišností notací ER diagramu. Pro vyjádření kardinality se používá buď grafické znázornění, nebo označení číslem na obou stranách vztahu v případě starších notací, např. Chenova \cite{dbVsb}. Povinnost bývá vyjádřena nejčastěji graficky, buď stylem čáry nebo určitým symbolem na stranách vztahu. Speciálním vyjádřením je dvojice (min, max), která vyjadřuje jak kardinalitu, tak povinnost. Jednotlivé notace se liší také tím, na které straně je informace vyjádřena. Rozlišujeme proto dva styly zápisu: \emph{look here} a \emph{look across} \cite{compErNotations}. 
		
		Pokud modelujeme situaci, ve které jeden zaměstnanec pracuje právě v jednom oddělení a~oddělení může mít několik zaměstnanců, v look across notaci zapíšeme 1 na stranu oddělení a~N na stranu zaměstnance. Pro notaci look here tomu bude přesně naopak. 
		
		%	To, na které straně je vyjádřena kardinalita a povinnost, nemusí být pro notaci jednotné. Chenova notace používá look across přístup pro vyjádření kardinality, ale povinnost vyjadřuje stylem look here, oproti tomu u notace Min-Max se obvykle dodržuje pouze jeden způsob pro kardinalitu i povinnost.
	
	\subsection{Chenova notace} \label{erDiagramFeatures}
	Jedná se o notaci představenou poprvé roku 1976 Peterem Chenem \cite{chenERD} a dodnes se jedná o jednu z nejvíce používaných. Tato notace podporuje \textit{n}-ární vztahy. Původní specifikace obsahovala prvky jen pro entity, vztahy, včetně kardinality, a atributy. Později byla rozšířena o rozlišení povinnosti vztahu a koncept generalizace/specializace. Pro povinnost se používá styl look here, pro kardinalitu look across. Na obrázku \ref{fig:chenExample} vidíme příklad použití této notace. V této části jsou rovněž popsány prvky používané při tvorbě ER diagramu. Na další notace a jejich rozdíly vhledem k~této notaci se zaměřuje kapitola \ref{secOftenNotation}.
	
	\begin{figure}[!h]
		\centering
		\includegraphics[width=0.65\textwidth]{Figures/NotationExChen}
		\caption[Příklad Chenovy notace]{Příklad Chenovy notace (Zdroj: \cite{whatIsERD})}
		\label{fig:chenExample}
	\end{figure}
	
		\subsubsection{Entitní typ}
		Entitní typy (často označovány v souvislosti s ERD jen jako entity) jsou jednoznačně identifikovatelné typy objektů vyskytující se v problémové doméně. Obvykle se označují podstatným jménem v jednotném čísle. Rozlišujeme následující typy entit:
	
		\begin{itemize}
			\item \textbf{Silný entitní typ} může existovat nezávisle na ostatních entitních typech, protože obsahuje alespoň jeden atribut, který entitu jednoznačně odlišuje od ostatních, značí se obdélníkem (viz obrázek \ref{fig:chenEntA}).
			
			\item \textbf{Slabý entitní typ} jehož existence je závislá na jiném entitním typu, protože neobsahuje atribut umožňující jednoznačnou identifikaci, značí se obdélníkem s dvojitým okrajem (viz.~obrázek \ref{fig:chenEntB}).
			
			\item \textbf{Asociativní entitní typ} slouží k vyznačení vztahu mezi entitami, obsahuje atributy identifikující tento vztah, značí se kosočtvercem uvnitř obdélníku (viz obrázek \ref{fig:chenEntC}).
		\end{itemize}
	
		\begin{figure}[H]
			\centering
			\subfloat[Silný entitní typ]
			{
				\includegraphics[width=0.2\textwidth]{Figures/ChenEntitiesA}
				\label{fig:chenEntA}
			}
			\subfloat[Slabý entitní typ]
			{
				\includegraphics[width=0.2\textwidth]{Figures/ChenEntitiesB}
				\label{fig:chenEntB}
			}	
			\subfloat[Asoc. entitní typ]
			{
				\includegraphics[width=0.2\textwidth]{Figures/ChenEntitiesC}
				\label{fig:chenEntC}
			}	
			\caption[Znázornění entit podle Chenovy notace]{Znázornění entit podle Chenovy notace}
		\end{figure}

		\subsubsection{Vztah}
		Vztah slouží k vyjádření asociace mezi entitními typy. Obecně vyjadřuje informace, které nelze vyjádřit pouhými entitními typy, např. student \textit{studuje} předmět, novinář \textit{napsal} článek. Označuje se slovesem. Znázorňuje se kosočtvercem (viz obrázek \ref{fig:chenRelA}). 
		
		Speciálním typem vztahu je identifikující vztah, který spojuje slabý entitní typ s entitním typem, na kterém je závislý, ten se označuje jako vlastník. Značí se kosočtvercem s dvojitým okrajem (viz.~obrázek~\ref{fig:chenRelB}). Podle počtu entit, které se v nich vyskytují rozlišujeme tyto typy:
		
		\begin{itemize}
			\item \textbf{Unární vztah}, ve kterém se vyskytuje pouze jedna entita, ta je ve vztahu sama se sebou (např. zaměstnanec \textit{je nadřízeným} jiného zaměstnance).
			\item \textbf{Binární vztah} existuje mezi dvěma entitami (např. zaměstnanec \textit{je vedoucím} oddělení).
			\item \textbf{Ternární vztah} existuje mezi třemi entitami najednou (např. učitel \textit{doporučuje} knihu třídě).
			\item \textbf{N-ární vztah} je mezi \textit{n} entitami zároveň. Jedná se o zobecnění předchozích uvedených vztahů.
		\end{itemize}
		
		Nejčastějšími typy vztahů jsou vztahy unární a binární. N-ární vztahy, kde $n > 2$, se vyskytují v ER diagramech velmi málo, protože vedou k problémům s dekompozicí na několik binárních vztahů při přechodu z konceptuálního modelu na logický.
		
		\begin{figure}[!h]
			\centering
			\subfloat[Vztah]
			{
				\includegraphics[width=0.2\textwidth]{Figures/ChenRelationshipsA}
				\label{fig:chenRelA}
			}
			\subfloat[Identifikující vztah]
			{
				\includegraphics[width=0.2\textwidth]{Figures/ChenRelationshipsB}
				\label{fig:chenRelB}
			}	
			\caption[Znázornění vztahů podle Chenovy notace]{Znázornění vztahů podle Chenovy notace}
		\end{figure}
	
		Vztahy dále dělíme podle kardinality, která udává, kolikrát může instance entitního typu být ve vztahu s instancí jiného entitního typu, pro binární typ vztahu  rozlišujeme kardinalitu 1:1, 1:N, M:N. Pro ternární typ vztahu rozlišujeme kardinalitu 1:1:1, 1:1:N, 1:N:M, a M:N:P, pro \textit{n}-ární typy vztahu se typy kardinality odvozují analogicky. Poslední důležitou vlastnosti vztahu je povinnost, určující zda může instance entitního typu existovat bez vztahu k jiné instanci entitního typu. Rozlišujeme povinné a nepovinné vztahy.
		
		\subsubsection{Atribut}
		Atributy jsou vlastnosti charakterizující entitní typ. Označují se podstatným jménem, znázorňují se elipsou. Rozlišujeme následující kategorie:
		
		\begin{itemize}
			\item \textbf{Jednoduchý atribut}, nelze dále dělit (např. \textit{značka automobilu}, viz obrázek \ref{fig:chenAttrA}).
			\item \textbf{Složený atribut} se dělí na více atomických atributů (např. \textit{adresa} se dělí na \textit{město, ulici a PSČ}, viz.~obrázek~\ref{fig:chenAttrB}).
			\item \textbf{Odvozený atribut}, jehož hodnota je vypočtena na základě hodnot ostatních atributů. Fyzicky nemusí v relační databázi existovat, znázorněn je elipsou s čárkovanou hranou (např. \textit{průměrná mzda}, viz obrázek \ref{fig:chenAttrC}).
		\end{itemize}
	
		\begin{figure}[!h]
			\centering
			\subfloat[Jednoduchý atribut]
			{
				\includegraphics[width=0.2\textwidth]{Figures/ChenAttrA}
				\label{fig:chenAttrA}
			}
			\subfloat[Složený atribut]
			{
				\includegraphics[width=0.2\textwidth]{Figures/ChenAttrB}
				\label{fig:chenAttrB}
			}
			\subfloat[Odvozený atribut]
			{
				\includegraphics[width=0.2\textwidth]{Figures/ChenAttrC}
				\label{fig:chenAttrC}
			}	
			\caption[Znázornění atributů podle Chenovy notace]{Znázornění atributů podle Chenovy notace}
		\end{figure}
	
		Další rozdělení je podle počtu hodnot atributu na:
	
		\begin{itemize}
			\item \textbf{Jednohodnotové} atributy obsahují pouze jednu hodnotu (např. \textit{rodné číslo}).
			\item \textbf{Vícehodnotové} atributy mohou obsahovat více hodnot, značí se elipsou s dvojitým okrajem (např. \textit{telefonní číslo na pevnou linku i mobilní telefon}.
		\end{itemize}).
			
		Označení atributů lze kombinovat, např. \textit{jednohodnotový odvozený atribut}.
		
	\subsection{Často používané notace} \label{secOftenNotation}
	Jak už bylo zmíněno, notací existuje celá řada. Jednotlivé notace se v mnoha směrech liší. V~této kapitole jsou vybrané notace popsány včetně příkladů. Všechny příklady modelují situaci, kdy jeden člověk má právě jedno místo narození a na jednom místě narození se mohlo narodit více lidí.
	
		\subsubsection{Bachmanova notace} \label{bachman}
		Tento typ notace podporuje nejvýše binární vztahy, vyjádření kardinality používá styl look across, povinnost pak look here, stejně jako je tomu u Chenovy notace. Bachmanova notace \cite{compErNotations} modeluje cizí klíče už na konceptuální úrovni, její předpokládané použití je tedy modelování relačních databází. Entity jsou znázorněny obdélníky, vztahy čárami. Vztahům není možné přiřadit atributy, pokud potřebujeme u vztahu M:N přidat neklíčový atribut, je nutná dekompozice pomocí asociační entity. Povinnost vztahu vyjadřuje kruh bez výplně, pro nepovinné vztahy, povinný vztah je naopak vyjádřen plným černým kruhem. Povinnost je vyjádřena vždy na konci vztahu. Pokud čára končí šipkou, jedná se o kardinalitu N, 1 se značí pouhou čárou bez symbolu. Příklad diagramu v Bachmanově notaci vidíme na obrázku \ref{fig:notationExBachman}.
		
		\begin{figure}[!h]
			\centering
			\includegraphics[width=0.75\textwidth]{Figures/NotationExBachman}
			\caption[Příklad Bachmanovy notace]{Příklad Bachmanovy notace (Zdroj: \cite{whatIsERD})}
			\label{fig:notationExBachman}
		\end{figure}
		
		\subsubsection{Crow's foot notace} \label{crowsfoot}
		Tato notace se označuje také jako Information engineering nebo Martinova notace \cite{compErNotations}. Opět podporuje nejvýše binární vztahy, které jsou znázorněny čárami. Není možné  přiřazovat atributy vztahu bez asociační entity. Kardinalita i povinnost vztahu používá look across styl a obojí je znázorněno graficky. Entity jsou znázorněny obdélníky, do kterých jsou kromě samotného názvu vepsány také všechny atributy. Zajímavé je, že ačkoli každá notace používá své grafické symboly, tak znaky pro znázornění kardinality a povinnosti použité touto notací najdeme velmi často v~kombinaci s jinými notacemi, jako je např. IDEF1X (viz kapitola \ref{idef1x}). Tato notace je populární zejména v oblasti CASE nástrojů. Příklad použití je vyobrazen na obrázku \ref{fig:notationExCrow}.
		
		\begin{figure}[!h]
			\centering
			\includegraphics[width=0.75\textwidth]{Figures/NotationExCrow}
			\caption[Příklad Crow's foot notace]{Příklad Crow's foot notace (Zdroj: \cite{whatIsERD})}
			\label{fig:notationExCrow}
		\end{figure}
		
		\subsubsection{Barkerova notace} \label{barker}
		Barkerova notace \cite{compErNotations} je velmi populární v oblasti tvorby datových modelů pro Oracle Database. Vznikla roku 1981 a po příchodu Richarda Barkera do společnosti Oracle se stala v této oblasti velmi populární. Jedná se o notaci podporující nejvýše binární vztahy, které jsou vyjádřeny čárami. Plná čára symbolizuje povinný vztah, čárkovaná pak vztah nepovinný. Pro vyjádření kardinality je zde použít také symbol vraní nohy jako u Crow's foot notace (viz kapitola \ref{crowsfoot}). Povinnost používá styl look here, kardinalita pak styl look across. Ukázku této notace vidíme na obrázku \ref{fig:notationExBarker}. Atributy jsou zde trojího typu, každý typ označuje kategorii atributu. Atributy se uvádí volitelně. Notace používá tyto znaky pro kategorizaci atributů:
		
		\begin{itemize}
			\item \textbf{\#} pro vyznačení identifikujícího atributu.
			\item \textbf{\textasteriskcentered} pro vyznačení povinného atributu.
			\item \textbf{$\circ$} pro vyznačení nepovinného atributu.
		\end{itemize}
	
		\begin{figure}[!h]
			\centering
			\includegraphics[width=0.75\textwidth]{Figures/NotationExBarker}
			\caption[Příklad Barkerovy notace]{Příklad Barkerovy notace \cite{whatIsERD}}
			\label{fig:notationExBarker}
		\end{figure}
	
		Oproti ostatním notacím zde nalezneme určitá specifika. Prvním z nich je tzv. UID čára (viz obrázek \ref{fig:barkerUid}), která se kreslí pouze u slabých entitních typů a vyjadřuje, že je identifikován atributy silných entitních typů. 
		
		\begin{figure}[!h]
			\centering
			\includegraphics[width=0.65\textwidth]{Figures/BarkerUid}
			\caption[Specifika Barkerovy notace - UID]{Specifika Barkerovy notace - UID}
			\label{fig:barkerUid}
		\end{figure}
		
		Dalším specifikem, je možnost vyznačit nepřenositelný vztah (viz obrázek \ref{fig:barkerNonTransferable}). Pokud jej použijeme, už jej nelze později změnit. Příkladem je vztah mezi kapitolou a knihou, kdy kapitolu z jedné knihy nemůžeme přiřadit knize druhé. Graficky se tento typ vztahu značí přidáním kosočtverce k vraní noze.
		
		\begin{figure}[!h]
			\centering
			\subfloat[Nepřenositelný vztah]
			{
				\includegraphics[width=0.2\textwidth]{Figures/BarkerNonTrans}
				\label{fig:barkerNonTransferable}
			}
			\qquad
			\subfloat[Podtypy]
			{
				\includegraphics[width=0.2\textwidth]{Figures/BarkerSubtypes}
				\label{fig:barkerSubtypes}
			}
			\caption[Specifika Barkerovy notace]{Specifika Barkerovy notace}
		\end{figure}
	
		Notace podporuje také dědičnost, kdy podtypy dědí atributy nadřazeného typu (viz obrázek \ref{fig:barkerSubtypes}). Graficky je tento jev vyjádřen přidáním obdélníků jednotlivých podtypů do společného obdélníku, který odpovídá nadřazenému typu.
		
		\subsubsection{Min-Max notace} \label{minmax}
		Jedná se o notaci, která podporuje nejvýše binární vztahy. Pro vyjádření kardinality a povinnosti vztahu, zde není použit žádný grafický symbol, ale uspořádaná dvojice $(min, max)$, kde minimální počet instancí entitního typu ($min$), které musí ve vztahu participovat, určuje povinnost, maximální počet ($max$) určuje kardinalitu. Styl pro kardinalitu a povinnost se používá jednotný, zpravidla look here (viz obrázek~\ref{fig:notationExMinMax}).
		
		\begin{figure}[!h]
			\centering
			\includegraphics[width=0.75\textwidth]{Figures/NotationExMinMax}
			\caption[Příklad Min-Max notace]{Příklad Min-Max notace \cite{whatIsERD}}
			\label{fig:notationExMinMax}
		\end{figure}
	
		\subsubsection{IDEF1X notace} \label{idef1x}
		IDEF1X \cite{compErNotations} je notace, která vnikla v rámci programu ICAM financovaném US Air Force, jako součást IDEF technik pro modelování informačních systémů. Vztahy jsou podporované nejvýše binární a neklíčové atributy vztahu je nutné modelovat použitím asociační entity. Kardinalita a~povinnost vztahu je vyjádřena pomocí $(min, max)$ notace buď graficky nebo textově. Nejčastěji používá styl look across. Tato notace rozlišuje graficky silné a slabé entitní typy. Podobně jako u~Barkerovy notace je zde možné vyznačit identifikující vztahy. Navzdory tomu, že notace nabízí vlastní grafické symboly pro znázornění kardinality a povinnosti vztahu, je často použita pro tento účel část Crow's foot notace (viz kapitola \ref{crowsfoot}), zbytek prvků IDEF1X je ponechán. Ukázku použití zachycuje obrázek \ref{fig:notationExIDEF1X}.
		
		\begin{figure}[!h]
			\centering
			\includegraphics[width=0.75\textwidth]{Figures/NotationExIDEF1X}
			\caption[Příklad IDEF1X notace]{Příklad IDEF1X notace \cite{whatIsERD}}
			\label{fig:notationExIDEF1X}
		\end{figure}
	
	\subsection{Nevýhody ER diagramů}
	ER diagramy jsou určeny primárně pro vytváření modelů relačních struktur. Pokud pracujeme s nestrukturovanými daty, které není jednoduše možné reprezentovat relacemi, není ER diagram vhodným vizualizačním nástrojem. Toto omezení platí i pro částečně strukturovaná data, jako např. XML nebo JSON. Navzdory tomu, že jsme schopni rozlišit jednotlivé entitní typy, může dojít k situaci, kdy se entity téhož typu liší svými atributy. 
	
	\subsection{Notace použitá ve vyvíjeném nástroji}
	Nástroj je určen pro návrh a správu relačních schémat v rámci již fyzicky existujících databází. Pro tuto činnost je používán výhradně fyzický model, protože je nutné pracovat s konkrétními datovými typy daného SŘBD a integritními omezeními v podobě primárních a cizích klíčů. Z~tohoto důvodu byla zvolena Oracle CASE notace, která vychází z Barkerovy notace. Z důvodu práce na nejnižší úrovni abstrakce je tato notace modifikována. Kardinalitu i povinnost vyjadřuje notace graficky. Styl look-here pro povinnost a look-across pro kardinalitu je z původní notace zachován. Vztahy jsou podporovány pouze unární a binární, modelování podtypů umožněno není. Ukázku vidíme na obrázku \ref{fig:notationERDModeler}.
	
	\begin{figure}[!h]
		\centering
		\includegraphics[width=0.75\textwidth]{Figures/ScreenNotationEx}
		\caption{Ukázka notace použité ve vyvíjeném nástroji}
		\label{fig:notationERDModeler}
	\end{figure}
	
	\subsection{Shrnutí}
	Každá notace má své klady i zápory. Volba notace by měla vycházet z potřeb pro tvorbu konkrétního modelu. Největší rozdíl mezi notacemi představuje možnost modelování ternárních vztahů, případně i vztahů s vyšší aritou. Proto je nutné zvážit zda sémantické možnosti binárních notací jsou pro vytvářený model dostatečné. 
	
	Znázornění kardinality a povinnosti se u jednotlivých notacích liší spíše graficky a všechny zmíněné notace poskytují v této oblasti takřka identické možnosti. Mezi poslední parametry, které mohou volbu notace ovlivnit, řadíme možnost modelování cizích klíčů na konceptuální úrovni. Tímto sice dojde k snížení úrovně abstrakce, nicméně konverze na fyzický model je poté jednodušší. Posledním kritériem je možnost modelování odvozených typů a nepřenositelných vztahů. Toto kritérium, ale nabídku notací velmi omezí. Přehledné srovnání vybraných notací nabízí tabulka \ref{tab:notationCmp}.
	
	\begin{table}[h!]
		\centering
		\caption{Srovnání vybraných notací}
		\label{tab:notationCmp}
		\begin{tabular}{l c c c c c c}
			\toprule
			Vlastnost & Chen & Bachman & Crow's foot & Berker & Min-Max & IDEF1X \\
			\midrule
			Ternární vztahy & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark \\
			Look-across kardinalita & \cmark & \cmark & \cmark & \cmark & \xmark & \cmark \\
			Look-across povinnost & \xmark & \xmark & \cmark & \xmark & \xmark & \cmark \\
			(Min, Max) notace vztahů & \xmark & \xmark & \cmark & \xmark & \cmark & \cmark \\
			Neklíčové atributy vztahů & \cmark & \xmark & \xmark & \xmark & \xmark & \xmark \\
			Cizí klíče na koncept. úrovni & \xmark & \cmark & \xmark & \xmark & \xmark & \cmark \\
			Podtypy & \cmark & \cmark & \cmark & \cmark & \cmark & \xmark \\
			\midrule
		\end{tabular}
	\end{table}

\newpage
\section{Popis a srovnání stávajících CASE nástrojů pro modelování relačních databází}
V dnešní době je využití CASE nástrojů v mnoha fázích softwarového procesu de~facto standardem. Jinak tomu samozřejmě není ani u návrhu datových modelů. Na trhu nalezneme celou řadu nástrojů od komerčního softwaru po open-source projekty podporující tvorbu ER diagramů. Tyto nástroje z pravidla nenabízí pouze grafický editor pro vytváření těchto diagramů pro programovou dokumentaci, ale obsahují řadu dalších užitečných funkcí, jako je např. generování patřičných DDL skriptů.
	
	\subsection{Výhody a nevýhody CASE nástrojů pro modelování relačních databází}
	Jednou z největších výhod je urychlení vývoje rozsáhlých projektů, protože spousta činností lze použitím CASE nástrojů automatizovat. Mnoho z nástrojů umožňuje také vygenerování ER diagramu z existující databáze nebo na základě DDL skriptu. Stejně tak lze některé nástroje využít k tvorbě objektově-relačního mapování pro přístup k datovému zdroji, což ušetří mnoho času a práce. 
	
	Použití CASE nástrojů s sebou nenese jen samá pozitiva. Největším problémem je obvykle nulová podpora pro provedení formální analýzy vytvořeného modelu, nástroje plně spoléhají na odborné znalosti uživatele. Dalším problémem je časová investice nutná k naučení se efektivně pracovat s daným nástrojem. Tento problém se netýká pouze modelování relačních databází, ale projevuje se u většiny specializovaných nástrojů.	Za poslední nevýhodu považuji cenu komerčních nástrojů, protože zejména u menších projektů nemusí být využity veškeré možnosti, které daný produkt nabízí a týmové licence mohou být velmi drahé. Řešením je použití freeware nástrojů, případně tzv. community verze některého z nástrojů, pokud to licenční politika dovolí.
	
	\subsection{Srovnání stávajících nástrojů}
	Cílem práce je vytvoření CASE nástroje, který podporuje Oracle Database a Microsoft SQL Server. Právě podpora SŘBD se stala primárním požadavkem při volbě porovnávaných nástrojů. Každý z následujících nástrojů tedy podporuje alespoň jeden z dvojice uvedených SŘBD. Každý z~následujících nástrojů nabízí alespoň zkušební verzi pro otestování jeho funkcionality. V ideálním případě je možné pořídit licenci pro studenty zdarma nebo využít bezplatné community edice. Odkazy na oficiální webové stránky testovaných CASE nástrojů a zmíněných SŘBD jsou k dispozici v příloze \ref{secAddCase}. 
	
		\subsubsection{Oracle SQL Developer Data Modeler}
		Autorem prvního nástroje je firma Oracle, která jej vyvíjí od roku 2008. Data Modeler je šířen bezplatně a nainstalovat jej můžeme buď samostatně nebo v rámci nástroje SQL Developer. 
		
		%Ten je ovšem zaměřen na správu existujících Oracle databází, takže možnosti modelování jsou oproti samostatné instalaci Data Modeleru limitovány.
		
		\paragraph{Popis funkcionality}
		Data Modeler nabízí tvorbu modelů na dvou úrovních abstrakce: logický model a relační (fyzický) model. Výhodou je možnost vygenerování několika oddělených relačních modelů z jediného logického pro vizualizaci možných schémat před samotným nasazením. V~nabídce je trojice notací pro logický model. Implicitně je použita Barkerova notace (viz kapitola \ref{barker}), která je v oblasti Oracle databází nejpoužívanější, nicméně ji lze přepnout na Bachmanovu (viz kapitola \ref{bachman}) nebo Information engineering (viz kapitola \ref{crowsfoot}). Oproti jiným nástrojům tuto možnost volby oceňuji, protože si každý uživatel může notaci nastavit podle svých preferencí. Pro relační model už možnost volby neexistuje a je použita modifikovaná Barkerova notace, označována někdy také jako Oracle CASE notace.
		
		Diagramy je možné exportovat ve formátu PDF, případně ve formě PNG nebo JPEG obrázku. Pro samotný relační model je možností exportu hned několik. Pokud nechceme použít nativní formát nástroje Data Modeler, můžeme exportovat do CSV. V tomto případě vznikne hned několik CSV souborů, rozdělených podle jednotlivých prvků (tabulek, vztahů apod.) diagramu.  Dalšími možnostmi je XMLA nebo Cube View Metadata, používané v kombinaci s DB2 (viz výpis \ref{src:xmlOracle}). \\
				
		%		<xs:element name="Oddeleni" msprop:FriendlyName="Oddeleni" msprop:DbSchemaName="dbo" msprop:DbTableName="Oddeleni" msprop:TableType="Table">
		\begin{lstlisting}[language=xml,label=src:xmlOracle,caption=Příklad části exportu do XMLA]
		<xs:complexType>
			<xs:sequence>
				<xs:element name="idOdd" msdata:ReadOnly="true" msdata:AutoIncrement="true" msprop:FriendlyName="idOdd" msprop:DbColumnName="idOdd" msprop:DataSize="-1" type="xs:integer" />
				<xs:element name="nazev" msdata:ReadOnly="true" msdata:AutoIncrement="true" msprop:FriendlyName="nazev" msprop:DbColumnName="nazev" msprop:DataSize="100" type="xs:VARCHAR " />
				<xs:element name="kod" msdata:ReadOnly="true" msdata:AutoIncrement="true" msprop:FriendlyName="kod" msprop:DbColumnName="kod" msprop:DataSize="4" type="xs:CHAR " />
			</xs:sequence>
		</xs:complexType>
		\end{lstlisting}
		%		</xs:element>
		
		Nástroj podporuje vygenerování DDL skriptu na základě relačního modelu. Před exportem je nutné nastavit požadovaýé SŘBD. V nabídce je Oracle Database, Microsoft SQL Server a~IBM DB2, všechny zmíněné jsou podporovány v několika verzích. Exportování DDL skriptu je doprovázeno kontrolou chyb, což napomáhá k odhalení problémů ještě před samotným spuštěním skriptu.
		
		Možností importu je opět několik. Importovat lze nejen z CSV, Data Cube metadat, XMLA nebo nativní formát nástroje Data Modeler, ale také přímo DDL skript. Tato možnost je výhodná v případě vizualizace již existujících schémat. Ta nejvíce praktickou ovšem považuji možnost importu pomocí data dictionary, které umožňuje připojení k existující databázi přes JDBC. Tento způsob importu je možné využít nejen pro Oracle, ale také pro Microsoft SQL Server a IBM DB2 (viz příloha \ref{secAddCase}).
		
		Po importu a reverzním vytvoření diagramu nástroj umožňuje rovněž aktualizaci schématu databáze na základě změn v ER diagramu. Změny se neprovádějí ihned po provedení, ale synchronizaci  je nutné spustit ručně. Tento způsob implementace umožňuje nepotvrzené změny jednoduše vrátit zpátky synchronizací diagramu s aktuálním schématem databáze.
		
		\paragraph{Popis grafického editoru}
		Grafický editor reaguje při manipulaci s objekty poměrně rychle, nicméně při přesunu entity nepříjemně problikávají. Vlivem otočení jsou špatně rozlišitelné symboly pro znázornění kardinality. Tento problém zachycuje obrázek \ref{fig:oracleBug}.
		
		\begin{figure}[!h]
			\centering
			\includegraphics[width=0.75\textwidth]{Figures/EditorOracleLogic}
			\caption{Chyby grafického editoru v Oracle SQL Developer Data Modeler}
			\label{fig:oracleBug}
		\end{figure}
		
		\paragraph{Nevýhody}
		V průběhu používání jsem se setkal s několika problémy, které nejčastěji souvisely s grafickým editorem diagramů. Nepříjemná je drag and drop funkcionalita pro přidání existujících tabulek do diagramu. Pozice kde tabulku umístíme přetažením je ignorováno a Data Modeler ji umístí obvykle jinde. Po přetažení se navíc otevře detail struktury tabulky, což je nepříjemné, zejména pokud máme v úmyslu přidat více tabulek. 
		
		Nejzávažnější problém se vyskytl při převádění logického modelu na relační, kdy vztahy kardinality M:N byly převedeny chybně. Došlo sice k vytvoření asociační tabulky, ale bohužel přibyly atributy cizích klíčů také v obou tabulkách z logického modelu (viz obrázek \ref{fig:oracleBug}). 
		V logickém modelu je tedy nutné nejprve vytvořit ručně asociační entitu, byť neobsahuje žádné neklíčové atributy, a~vztah převést na dvojici identifikujících vztahů 1:N. Po tomto opatření již proběhne převod správně. 
		
		Nepříjemná je také nutnost vytvoření nového relačního schématu ještě před jeho vygenerováním, protože jinak je vygenerováno relační schéma opakovaně do stejného diagramu a veškeré prvky se vyskytuji duplicitně. V této situaci nezbývá nic jiného než smazat veškerý obsah diagramu a vygenerovat jej znova, protože příkaz \textit{zpět} tento problém neřeší. Dalším častým problémem je zobrazování dialogových oken mimo viditelnou plochu obrazovky po odpojení sekundárního monitoru. Problém je možné vyřešit smazáním konfiguračního souboru s lokálním uživatelským nastavením.
		
		\subsubsection{Toad Data Modeler}
		Další nástroj je vyvíjen od roku 2006 firmou Quest Software. Jedná se o komerční produkt určený pro operační systém Microsoft Windows. Toad podporuje více než 10 různých SŘBD v několika verzích, mezi nimi např. Oracle Database, Microsoft SQL Server nebo PostgreSQL (viz příloha \ref{secAddCase}).
		
		\paragraph{Popis funkcionality}
		Toad umožňuje vytvořit 3 typy modelů: fyzický, logický a univerzální. Nejpoužívanější je fyzický model, který je cílen na konkrétní SŘBD, další možností je logický model, ten se ovšem doporučuje jen v případě využití dědičnosti. Posledním typem je univerzální model, který umožňuje tvorbu diagramu bez návaznosti na konkrétní SŘBD, případně pokud určený SŘBD není mezi podporovanými. Notace jsou tentokrát v nabídce pouze dvě, implicitně nastavený Information Engineering (viz kapitola \ref{crowsfoot}) a volitelná IDEF1X (viz kapitola \ref{idef1x}).
		
		Export je možné provést do CSV. Dle mého názoru je export řešen lépe než v nástroji Oracle SQL Developer Data Modeler, protože CSV soubor je exportován pouze jeden. Další možnosti je export do XLS. Poslední možností je export ve formě obrázku. Tato volba nabízí mnoho nastavení od velikosti plátna nebo rozdělení na stránky pro tisk po kompresi a barevnou hloubku.
		
		Z diagramu je možné vygenerovat DDL skript pro všechny podporované SŘBD bez ohledu na to, jaký byl zvolen při zakládaní projektu. DDL skripty je možné generovat buď úplné nebo obsahující jen změny v diagramu provedené v případě reverzního vygenerování. Takto vygenerovaný skript neobsahuje pouze tabulky a integritní omezení, ale může zahrnovat i uložené procedury, funkce, triggery nebo indexy. 
		
		Nástroj umožňuje rovněž kontrolu vytvořeného modelu než přejdeme ke generování skriptů. Fyzických modelů umožňuje vytvořit Toad Data Modeler několik v jednom projektu a následně je schopen provést jejich porovnání a přehledně vypsat v čem se liší. Modely je možné dokonce i sloučit. Další zajímavou volbou je možnost migrace na jiný SŘBD než z jakého byl model importován.
		
		Import modelu je možný nejen z CSV, XLS a nativního formátu, ale také z jiných aplikací, konkrétně ER/Studio Data Architect a Toad for Oracle. Vytvoření modelu z DDL skriptu bohužel v případě tohoto nástroje chybí. Samozřejmostí je reverzní vygenerování modelu z připojené databáze. Do projektu zde lze zahrnout i indexy, procedury a další objekty z databáze, které poté mohou být rovněž součástí DDL skriptu.
		
		Aktualizace databáze na základě změn v ER diagramu je možné provádět buď spuštěním vygenerovaného DDL skriptu obsahující změny samostatně, nebo lze využít definovaného připojení a změny provést přes GUI. Toad Data Modeler nabízí uložení modelů v různých fázích úprav, tento přístup umožňuje modely porovnat a případně vygenerovat skript na základě rozdílů mezi nimi.
		
		Velmi užitečnou funkcí je možnost vytváření reportů. Reporty lze generovat do PDF nebo jako statické webové stránky, což je výhodné pro tvorbu dokumentace. Report obsahuje kompletní datový slovník, přehledně vypsané informace o integritních omezeních, zdrojové kódy uložených funkcí, procedur a mnoho dalšího. Před vygenerováním lze nastavit, co vše má být v~reportu obsaženo. Příklad reportu vidíme na obrázku \ref{fig:toadReport}.
		
		\begin{figure}[!h]
			\centering
			\includegraphics[width=1\textwidth]{Figures/EditorToadReport}
			\caption[Report v podobě webové stránky z Toad Data Modeleru]{Report v podobě webové stránky z Toad Data Modeleru}
			\label{fig:toadReport}
		\end{figure}
		
		\paragraph{Popis grafického editoru}
		Grafický editor pro tvorbu diagramů reaguje velmi rychle a za dobu testování jsem se nesetkal s žádnými výraznými problémy. Zobrazení entit lze měnit od  pouhého názvu po detailní výpis atributů. Vztahům lze přidávat popisky, které lze v případě potřeby vypnout. Pracovní plocha je rozdělena na části velikosti A4, kvůli rozvržení pro tisk. Nevýhodou je absence mřížky, ke které by šly objekty přichytávat. Vztahy jsou reprezentovány lomenou čárou, úhly jsou vždy pravé, což považuji za velké plus z pohledu přehlednosti. Do pracovní plochy lze kromě entit a~vztahů vkládat také text a základní geometrické tvary. Tato možnost je využitelná pro tvorbu popisků.
		
		\paragraph{Nevýhody}
		Jeden z mála problémů, se kterým jsem se setkal, bylo hromadné přidání všech tabulek a vztahů z existující databáze do diagramu. Tabulky se všechny umístily do jednoho místa a~bylo je nutné postupně rozprostřít po větší ploše. Naštěstí výrobce na tento problém nenechal bez povšimnutí a v nabídce je volba \textit{autolayout}. Ta má za následek automatické uspořádání tabulek tak, aby se nepřekrývaly. Rozložení je možné shora dolů, zleva doprava nebo abecedně do obdélníku. Podobně lze znova vykreslit vztahy. Dokonce lze i zakázat křížení vizualizace vztahů, vyhledávání tras je velmi rychlé a dokonce ani po zapnutí volby pro co nejpřesnější trasy nepřesáhl čas řádově jednotky sekund. 
		
		Jedinou výtkou k nástroji Toad Data Modeler je nepřehlednost uživatelského rozhraní. Jedná se o~opravdu velmi komplexní nástroj a to mělo na GUI pravděpodobně největší dopad. Hlavní menu obsahuje sice optimální počet položek a není překombinované, nicméně o nástrojové liště to říct nelze. Ukázku nástrojové lišty vidíme na obrázku \ref{fig:toadMenu}. Většina funkcionality je směřovaná zde a~novému uživateli zabere nějaký čas než prozkoumá veškeré možnosti, výhodou je velké množství klávesových zkratek, které velmi usnadňují práci. Problém způsobovalo také rozvržení spodních panelů na obrazovce s nižším rozlišením, nicméně přesunutí panelů fungovalo bez problémů a~na obrazovce s FullHD rozlišením se problém neprojevil.
		
		\begin{figure}[!h]
			\centering
			\includegraphics[width=1\textwidth]{Figures/EditorToad}
			\caption[Nástrojová lišta nástroje Toad Data Modeler]{Nástrojová lišta nástroje Toad Data Modeler}
			\label{fig:toadMenu}
		\end{figure}
		
		\subsubsection{SQL Server Management Studio}
		Tento nástroj, často označován jen jako SSMS, je vyvíjen společnosti Microsoft. První verze byla vydaná společně s Microsoft SQL Server 2005. Předchůdcem toho nástroje je Enterprise Manager, který se používal ke správě starších verzí SŘBD SQL Server. Jedná se o plnohodnotný nástroj pro administraci SŘBD SQL Server. Většinu potřebných úkonů je možné provést s využitím GUI. Součástí tohoto nástroje je také možnost tvorby ER diagramů a právě na ní se zaměříme. Nástroj je určen pro platformu Microsoft Windows a kromě SQL Serveru nepodporuje žádné další SŘBD.
		
		\paragraph{Popis funkcionality}
		Management studio umožňuje pouze tvorbu fyzického modelu databáze. Nemožnost tvorby modelů na jiných úrovní abstrakce je způsobena primárním zaměřením celého nástroje na správu již existujících databází. Konceptuální model tedy v tomto případě postrádá smysl. Použitá notace je specifická, tento nástroj nepoužívá žádnou z dříve zmíněných notací. Ukázku notace zachycuje obrázek \ref{fig:notSSMS} Povinnost vztahu je znázorněna graficky v look here stylu, kardinalita znázorněna není, předpokládá se 1:N. 
		
		\begin{figure}[!h]
			\centering
			\includegraphics[width=0.65\textwidth]{Figures/EditorSSMS}
			\caption[Notace SSMS]{Notace SSMS}
			\label{fig:notSSMS}
		\end{figure}
		
		Import diagramů z jiných nástrojů nebo souboru není k dispozici v žádné formě, jedinou možností je vytvoření databáze na serveru a vygenerování diagramu na základě jejího schématu. Stejně tak není podporován ani export do CSV, XLS nebo XML, jako je tomu u konkurenčních nástrojů. 
		
		Diagramy jsou uloženy ve speciální tabulce (\texttt{sysdiagrams}) přímo v databázi. V práci je tedy možné bez problémů pokračovat z jiného počítače aniž bychom museli kopírovat soubory projektu. Nástroj podporuje tisk diagramů, takto můžeme vytvořit i PDF nebo XPS.
		
		Reverzní generování diagramu umožňuje vizualizovat určitou část schématu, tato možnost je praktická zejména při práci s rozsáhlými systémy, kde lze schéma rozdělit na logické celky. Aktualizace schématu databáze prostřednictvím ER diagramu jsou velmi rychlé, stačí potvrzení změn uložením diagramu a patřičné změny se ihned promítnou v aktuálním schématu. Před potvrzením je možné zobrazit DDL skript obsahující SQL příkazy k modifikaci schématu. 
		
		Přepínání mezi diagramy funguje prakticky okamžitě, změny provedené v jednom jsou ihned zobrazeny v druhém, z tohoto pohledu je synchronizace na skvělé úrovni. Problém způsobilo jen přidání atributu do tabulky, ze které byl atribut se stejným názvem v dalším diagramu smazán, změny byly potvrzeny opožděně, nicméně tato situace skončila chybou a pomohlo jen smazání diagramů z databáze a jejich opětovné vygenerování. Tento fakt nepovažuji za zásadní selhání, protože se jedná o zcela neobvyklou operaci.
		
%		Vybraná část schématu, která je součásti diagramu, bohužel nejde exportovat ve formě DDL skriptu, je možné vytvořit pouze DDL skript pro jednotlivé tabulky a tyto dílčí části zkompletovat v textovém editoru podle potřeby.
		
		\paragraph{Popis grafického editoru}
		Grafický editor reaguje ve srovnání s ostatními nástroji nejrychleji z testovaných. Umožňuje přidat kromě objektů z databáze také popisky, stejně tak je možné přidávat popisky vztahům. Režimů zobrazení tabulek editor nabízí také několik, od pouhého názvu tabulky po zobrazení pouze klíčových atributů. V případě potřeby je možné využít automatické rozvržení, podobně jako u nástroje Toad Data Modeler, a celé schéma nechat přehledně uspořádat. 
		
		\paragraph{Nevýhody}
		Žádné problémy s grafickým editorem jako je špatné uspořádání čar, problikávání objektů a~podobně se nevyskytly. Práce je velmi intuitivní a editor neobsahuje zbytečné funkce. Právě tato jednoduchost má největší vliv na uživatelský komfort, který považuji za nejvyšší z testovaných nástrojů.
		
		\subsubsection{Visual Paradigm}
		Dalším testovaným nástrojem je komerční produkt od firmy Visual Paradigm International, zastřešuje ji Hong Kong Institute of Vocational Education, který je určen primárně pro tvorbu UML diagramů. Nástroj podporuje i modelování relačních databází formou ER diagramu. K dispozici je několik typů placených licencí rozdělených podle nabízených možností a také community edice, která je určena pro nekomerční projekty. Nevýhodou community edice je absence veškerých pokročilých funkcí pro práci s relační databázi, jako je např. reverzní generování diagramů.
		
		\paragraph{Popis funkcionality}
		Visual Paradigm podporuje tvorbu logických modelů bez nutnosti specifikovat SŘBD, ten je nutné uvést až při generování skriptu a nástroj podporuje více než deset různých systémů. Diagram používá Crow's foot notaci (viz kapitola \ref{crowsfoot}), bohužel je jediná podporovaná a nelze ji přepnout jako v případě jiných nástrojů. Možná nastavení pro vygenerovaní relačního schématu zachycuje obrázek \ref{fig:editVP}.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.55\textwidth]{Figures/EditorVP}
			\caption[Generování schématu databáze z ER diagramu ve Visual Paradigm]{Generování schématu databáze z ER diagramu ve Visual Paradigm}
			\label{fig:editVP}
		\end{figure}
		
		Diagramy je možné importovat v rámci projektu, samostatný import není možný. Diagramy můžeme importovat z nezávislých formátů jako je XML nebo i z jiných nástrojů, příkladem je konkurenční Enterprise Architect, Visio a několik dalších. 
		
		Nástroj nabízí tisk diagramů, pomocí této volby jsme schopni vytvořit i PDF nebo XPS soubor. Další možností exportu, kromě nativního formátu, je XML soubor a obrázek. Nastavení je poměrně detailní, lze nastavit formát, kompresi a dokonce i rozdělení diagramu na části specifikované svou velikostí. V případě XML můžeme ovlivnit jeho podobu volbou struktury.
		
		Nástroj podporuje generování DDL skriptu vytvořeného diagramu. Diagramy mohou obsahovat i uložené procedury, funkce a triggery, které mohou být také součásti  tohoto skriptu. Skript můžeme uložit do souboru nebo jej rovnou spustit nad definovaným připojením a modelované schéma tak fyzicky vytvořit v databázi. Oproti dalším nástrojům umí Visual Paradigm vygenerovat také kostru příkazů pro vložení a aktualizaci záznamů pro jednotlivé tabulky.
		
		Na rozdíl od jiných nástrojů je možné vytvořit z logického modelu také kostru pro objektově-relační mapování. Tuto volbu považuji za jeden z největších přínosů, protože pro rozsáhlé databáze ušetří obrovské množství času. Další užitečnou funkcí je i možnost synchronizace s třídním diagramem. Diagramy můžeme reverzně generovat z existující databáze nebo DDL skriptu. Synchronizace se schématem databáze není provedena okamžitě, ale je nutné ji spustit prostřednictvím GUI. 
		
		\paragraph{Popis grafického editoru}
		Práce s grafickým editorem je intuitivní, reakce působí svižně a nedochází k žádným problémům s výskytem grafických artefaktů. Zobrazení tabulek je možné všemožně upravovat, k~dispozici je i~mřížka, ke které lze objekty zachytávat. Samozřejmostí je i zobrazení popisků vztahů, případně dalších objektů. Uživatelské rozhání je, vzhledem ke komplexnosti nástroje, přehledně uspořádáno. Nástroj považuj za vhodnou volbu zejména pro rozsáhlejší projekty, kde je výhodné diagram datového modelu využít i v dalších diagramech.
		
		\paragraph{Nevýhody}
		Definování nového připojení k databázi je jedna ze slabých stránek nástroje, pro SQL Server jsou možnosti velmi omezené a chybí např. možnost autentikace pomocí Windows účtu. Pro testování jsem tedy musel vytvořit nový login a databázového uživatele. Samotné připojení k~databázi se pravděpodobně provádí na hlavním vlákně, což často způsobuje zamrznutí celého GUI.
		
		\subsubsection{StarUML 2}
		StarUML je poměrně nový nástroj, první verze byla vydaná roku 2014. Nástroj následuje trend desktopových aplikací vytvořených pomocí webových technologií. Tyto aplikace využívají pro svůj běh NodeJS, což umožňuje nasazení bez ohledu na platformu. Jedná se o komerční nástroj, pro testování jsem použil zkušební verzi. Licence pro studenty není zdarma, lze ji ale pořídit se slevou.
		
		\paragraph{Popis funkcionality}
		Nástroj podporuje pouze logický model, který používá Crow's foot notaci (viz kapitola \ref{crowsfoot}), jiné typy notací bohužel v nabídce nejsou. Model je vytvářen univerzálně, je možné  použití pro různé SŘBD. 
		
		Zde se dostáváme k největší výhodě nástroje, kterou je modularita. Použití webových technologií umožňuje velmi snadnou tvorbu doplňků, které lze instalovat z oficiálního repozitáře. Po instalaci dokonce nebyl nutný ani restart aplikace a nové možnosti byly dostupné ihned. Právě doplněk je nutný i pro generování DDL skriptu, protože samotná aplikace tuto možnost neobsahuje. Zmíněný doplněk v současné době podporuje MySQL a Oracle Database, zdrojové kódy jsou dostupné na serveru GitHub, což přináší možnost rozšířit funkcionalitu o další SŘBD. Konfiguraci doplňku pro generování DDL skriptu zachycuje obrázek \ref{fig:editStar}.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.55\textwidth]{Figures/EditorStar}
			\caption[Konfigurace doplňku pro generování DDL skriptu ve StarUML 2]{Konfigurace doplňku pro generování DDL skriptu ve StarUML 2}
			\label{fig:editStar}
		\end{figure}
		
		Importovat diagramy lze pouze z nativního formátu souboru a StarUML 1. Výhodou je, že nástroj ukládá diagramy ve formátu JSON, tento formát je možné využít pro případnou spolupráci s jinými nástroji. Export diagramu je možný ve formátu PNG, JPEG a dokonce SVG, což je vhodné pokud potřebujeme diagram využít i v jiném nástroji, který podporuje vektorové formáty, poslední možností je export do PDF. Nástroj umí vytvořit report ve formě webových stránek, zde nalezneme jak diagramy projektu, tak detailní popis tabulek, atributů a vztahů. 
		
		Nástroj bohužel nenabízí možnost reverzního generování diagramů z databáze, ani DDL skriptu. Stejně tak nástroj postrádá synchronizaci s již existujícím schématem. Možným řešením je modul, který by rozšířil nástroj o tuto funkcionalitu, v současné době se mi bohužel nepodařilo takový najít.
		\paragraph{Popis grafického editoru}
		Grafický editor nabízí všechny základní funkce pro vytváření ER diagramu a celkově působí uživatelské rozhraní přehledně. 
		
		\paragraph{Nevýhody}
		Za největší nedostatek považuji rychlost reakcí editoru. Zde se bohužel projevil nižší výkon použitých technologií oproti klasickému přístupu k vývoji desktopových aplikací. Při přesouvání objektů po plátně se editor velmi znatelně zadrhává. Vzhledem ke zbytku srovnávaných nástrojů je v tomto ohledu StarUML rozhodně nejhorší.
	
	\subsection{Shrnutí}
	Všechny testované nástroje nabízí alespoň základní funkcionalitu nutnou pro úspěšné vytvoření ER diagramu. Většina z nich se nezastavuje u pouhého grafického editoru s možností exportu DDL skriptu, ale nabízí mnoho komplexnějších funkcí. Hodnocen nebyl pouze grafický editor pro tvorbu diagramů, ale také možnosti reverzního generování diagramů z databáze a s tím spojená synchronizace s jejím schématem. Dalšími aspekty v hodnocení byly také možnosti importu a~exportu schémat, kdy XML nebo CSV mohou být výhodné z hlediska strojového zpracování nástroji pro formální analýzu, zatímco export do Excelu nebo PDF je využitelný pro tvorbu dokumentace projektu.
	
	Z hlediska grafického editoru považuji za nejlepší SQL Server Management Studio pro jeho rychlost a snadnou aplikaci změn na existující schéma. Bohužel jej nelze použít i pro jiná SŘBD. Stejně kvalitním editorem disponuje např. Visual Paradigm, který je vhodný pro jiné SŘBD, ale aplikace změn není tak přímočará jako u nástroje SQL Server Management Studio. Přehledné srovnání možností z pohledu grafických editorů nabízí tabulka \ref{tab:geditCmp}. Rychlost odezvy a přehlednost GUI je hodnocena známkou z intervalu 1 - 5 (1 = nejlepší, 5 = nejhorší).
	
	\begin{table}[h!]
		\centering
		\caption{Srovnání grafických editorů pro vybrané CASE nástroje}
		\label{tab:geditCmp}
		\begin{tabular}{l c c c c c}
			\toprule
			Vlastnost & SQL Dev. & Toad & SSMS & Visual Paradigm & StarUML \\
			\midrule
			Výchozí notace & Barker & IE & Vlastní & Crow's foot & Crow's foot \\
			Možnost volby notace & Ano & Ano & Ne & Ne & Ne \\
			Strojově čitelný export & Ano & Ano & Ne & Ano & Ano \\
			Export do PDS/XPS & Ano & Ano & Ano & Ano & Ano \\
			Export formou obrázku & Ano & Ano & Ne & Ano & Ano \\
			Rychlost odezvy & 3 & 2 & 1 & 1 & 4 \\
			Přehlednost GUI & 2 & 3 & 1 & 2 & 1 \\
			\midrule
		\end{tabular}
	\end{table}
	
	\newpage
	V oblasti synchronizace diagramu s existující databázi nabízí nejširší škálu možností Toad Data Modeler. Ostatní nástroje předčil podporou mnoha SŘBD, porovnáním modelů a detailními možnostmi nastavení generování DDL skriptu. Srovnání všech nástrojů v této oblasti nalezneme v tabulce \ref{tab:ddlCreateCmp}, komfort aktualizací schématu je opět hodnocen známkami 1 - 5, StarUML je z tohoto hodnocení vynechán, protože práci s databázi nepodporuje.
	
	\begin{table}[!h]
		\centering
		\caption{Srovnání možností synchronizace pro vybrané CASE nástroje}
		\label{tab:ddlCreateCmp}
		\begin{tabular}{l c c c c c}
			\toprule
			Vlastnost & SQL Dev. & Toad & SSMS & Visual Paradigm & StarUML \\
			\midrule
			Synchronizace s exist. schématem & Ano & Ano & Ano & Ano & Ne \\
			Podpora více SŘBD & Ano & Ano & Ne & Ano & Ano \\
			Reverzní generování - databáze & Ano & Ano & Ano & Ano & Ne \\
			Reverzní generování - DDL & Ano & Ano & Ano & Ano & Ne  \\
			Export kompletního DDL & Ano & Ano & Ne & Ano & Ano \\
			Export DDL se změnami & Ano & Ano & Ano & Ano & Ne \\
			Migrace na jiný SŘBD & Ano & Ano & Ne & Ano & Ne \\
			Komparace modelů & Ne & Ano & Ne & Ne & Ne \\
			Procedury v modelu & Ne & Ano & Ne & Ano & Ne \\
			Komfort aktualizace schématu & 1 & 2 & 1 & 3 & - \\
			\midrule
		\end{tabular}
	\end{table}
	
\newpage
\section{Návrh a implementace grafického editoru ER diagramů}
Grafický editor představuje jádro celého CASE nástroje, protože většina operací, které nástroj umožňuje, je prováděna prostřednictvím jeho rozhraní. Nástroj je implementován jako desktopová WPF aplikace \cite{wpf} určena pro operační systém Microsoft Windows. 
	
	\subsection{Architektura aplikace}
	S WPF aplikacemi se váže návrhový vzor MVVM \cite{mvvm}, který slouží k oddělení prezentační vrstvy od doménové logiky, včetně přístupu ke zdroji dat. Tento návrhový vzor je výhodný zejména pro vývoj rozsáhlejších aplikací, kdy čistě událostmi řízené programování může vést k obtížím s~laděním aplikace, případně pozdějším úpravám v oblasti grafického rozhraní. Jednotlivé části vzoru MVVM jsou znázorněny na obrázku \ref{fig:mvvm}. Vzor rozděluje aplikaci na tyto části: 
	
	\begin{itemize}
		\item \textbf{Model} slouží pro uchování dat aplikace. Modely obvykle obsahují také doménovou logiku jako na např. validace vstupních dat.
		
		\item \textbf{View} slouží k prezentaci dat a komunikaci s uživatelem. Veškerá interakce s konkrétními ovládacími prvky uživatelského rozhraní se provádějí v této vrstvě. 
		
		\item \textbf{ViewModel} funguje jako mezivrstva mezi view a modelem. Pokud dojde ke změně vlastností viewmodelu, view je o těchto změnách informováno a změnám se přizpůsobí. Viewmodel je nezávislý na prvcích uživatelského rozhraní. Z tohoto důvodu se zde využívá princip zvaný data-binding, který je popsán v kapitole \ref{secKeyPartsEditor}. 
	\end{itemize}
	
	\begin{figure}[!h]
		\centering
		\includegraphics[width=0.65\textwidth]{Figures/Mvvm}
		\caption[Blokové schéma komponent MVVM]{Blokové schéma komponent MVVM (Zdroj: \cite{mvvm})}
		\label{fig:mvvm}
	\end{figure}
	
	Aplikaci vzoru MVVM v praxi vidíme na obrázku \ref{fig:mvvmUsage}. Příklad zobrazuje strukturu komponenty pro vizualizaci tabulek v grafickém editoru. Plná čára zobrazuje asociaci mezi třídami. Vazba je jednosměrná, přímá komunikace mezi view a modelem tedy není možná, vše se odehrává prostřednictvím viewmodelu. Změny dat jsou přenášeny pomocí událostí, směr jejich propagace je značena čárkovanou čárou. Viemodel informuje view o změně dat pomocí události \texttt{PropertyChanged}. Model používá stejný princip při validaci dat, tedy událost \texttt{DataErrorInfo}.
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=1\textwidth]{Figures/EditorMvvm}
		\caption[Blokové schéma komponenty pro tabulky v grafickém editoru]{Blokové schéma komponenty pro tabulky v grafickém editoru}
		\label{fig:mvvmUsage}
	\end{figure}
	
	\subsection{Klíčové části grafického editoru} \label{secKeyPartsEditor}
	Grafický editor je stejně jako ostatní části aplikace navrhnut s ohledem na výše zmíněný návrhový vzor MVVM. Viewmodely ve WPF aplikacích slouží pro uchovávání dat pro jednotlivé komponenty GUI v podobě jaká vyhovuje prezentační vrstvě. Provázaní viewmodelů s prezentační vrstvou je řešeno principem, který se obecně označuje jako data-binding. Standardně se realizuje toto provázání v XAML kódu, který určuje strukturu uživatelského rozhraní aplikace. Ukázku data-bindingu pro textové pole určující přesnost datového typu vidíme na výpisu kódu~\ref{src:xamlDataBinding}. Grafický editor je z pohledu data-bindingu specifickou komponentou, zejména co se týká povahy prováděných operací, provázaní dat s prezentační vrstvou bylo tedy nutné implementovat alternativním způsobem. 
		
		\begin{lstlisting}[language=xml,label=src:xamlDataBinding,caption=Příklad data-bindingu v XAML pro textové pole]
		<TextBox x:Name="PrecisonTextBox"
			Grid.Column="1"
			IsReadOnly="True"
			controls:TextBoxHelper.UseFloatingWatermark="True"
			controls:TextBoxHelper.Watermark="Precision"
			Text="{Binding SelectedDatatype.Precision, Mode=OneWay, UpdateSourceTrigger=PropertyChanged}">
		</TextBox>
		\end{lstlisting}
		
		\subsubsection{Provázání editoru s daty}
		Dle MVVM obsahuje viewmodel grafického editoru trojici kolekcí pro uložení viewmodelů tabulek, vztahů a popisků, tedy objektů, které se vyskytují na plátně. Kolekce po přidání nebo odebraní objektu vyvolají událost, na kterou patřičným způsobem reaguje komponenta editoru. Viewmodel tedy vystavuje rozhraní grafického editoru ostatním částem aplikace. Pro přidání nové tabulky stačí jen vložit její viewmodel, s nastavenými hodnotami, do kolekce tabulek a editor se sám postará o přidání objektu na plátno. Není tedy nutná přímá interakce jiné komponenty s prezentační vrstvou grafického editoru. Tato implementace umožňuje pracovat s grafickým editorem na úrovni viewmodelu, stejným způsobem jako s komponentami využívajícími standardní způsob data-bindingu ve WPF aplikacích. 
		
		Pro ilustraci je proces odstranění tabulky z plátna zachycen sekvenčním diagramem na obrázku \ref{fig:sequenceRemoveTable}. Třída \texttt{DiagramFacade} slouží k zapouzdření operací nad viewmodely, její metody jsou volány z po úspěšném provedení akce uživatelem. Odstranění viewmodelu tabulky z kolekce ve třídě \texttt{DatabaseModelDesignerViewModel} vyvolá událost, na tu reaguje prezentační vrstva odstraněním příslušných objektů z plátna (třída \texttt{DesignerCanvas}).
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=1\textwidth]{Figures/SeqRemoveTableHiRes}
			\caption{Sekvenční diagram - odstranění tabulky z plátna}
			\label{fig:sequenceRemoveTable}
		\end{figure}
		
		\subsubsection{Vizualizace  tabulek}
		Implementace změny rozměrů a pozice tabulky na plátně je úzce spjatá s použitím WPF komponenty \texttt{Thumb}, která je nejčastěji využívaná v aplikacích určených pro dotykové displaye. Na první pohled se jeví jako nejsnazší řešení explicitní zachytávaní událostí vyvolaných po stisku tlačítka a tahu myši s následným výpočtem rozdílu mezi aktuálním a počátečním bodem. Problémem této implementace je obtížná generalizace tohoto řešení, protože zde vzniká závislost na implementaci komponenty pro grafické znázornění tabulky. Tuto závislost lze řešit právě použitím již zmíněné komponenty \texttt{Thumb} v kombinaci s XAML šablonou.
		
		\paragraph{Komunikace komponent grafického editoru s viewmodely}
		Pro zprostředkování komunikace mezi šablonou a viewmodelem tabulky slouží třída \texttt{TableContent}. Strukturu této části aplikace zachycuje třídní diagram na obrázku \ref{fig:classDiagResize}, ten je značně zjednodušený oproti implementaci, obsahuje jen položky důležité pro tuto kapitolu. Třída \texttt{TableContent} obsahuje referenci na viewmodel tabulky. Po interakci s \texttt{Thumb} objekty tedy zajistí aktualizaci patřičných hodnot v jeho vlastnostech. Třída \texttt{TableContent} slouží také k propagaci události pro přidání atributu, odstranění tabulky z databáze a mnohé další, tak aby komponenta pro grafické znázornění tabulky obsahovala co nejméně doménové logiky. 
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.85\textwidth]{Figures/EditorTabulky2}
			\caption{Část třídního diagramu - přesunutí a změna rozměrů tabulky}
			\label{fig:classDiagResize}
		\end{figure}
		
		 \texttt{Thumb} vyvolává událost na počátku tahu, v jeho průběhu a po ukončení tahu. Explicitní zachytávání událostí myší tedy není nutné, stejně tak rozdíl souřadnic počátečního a aktuálního bodu je součásti argumentu událostí. Šablona umožňuje nastavení společných základních vlastností pro jakoukoli implementaci komponenty pro tabulku, společně s definicí triggeru pro zviditelnění vrstvy umožňující změnu rozměrů tabulky po jejím výběru. Triggery reagují na změny hodnot ve viewmodelech, ukázka triggeru pro ovládání vrstvy umožňující změnu rozměrů je k vidění na výpisu kódu \ref{src:xamlTrigger}. Tímto způsobem je možné provádět úpravy komponenty pro zobrazení tabulky, aniž by došlo k narušení funkcionality přesunu a změny rozměrů. 
		
		\begin{lstlisting}[language=xml,label=src:xamlTrigger,caption=Příklad triggeru v XAML pro vrstvu umožňující změnu rozměrů]
		<ControlTemplate.Triggers>
			<Trigger Property="IsSelected" Value="True">
				<Setter TargetName="ItemDecorator" Property="ShowDecorator" Value="True"/>
			</Trigger>
		</ControlTemplate.Triggers>
		\end{lstlisting}
		
		Změna rozměrů využívá opět komponenty \texttt{Thumb}, která je nyní součástí tzv. adorner vrstvy, tato vrstva se zobrazí až po vybrání tabulky. Vybraním dojde k úpravě hodnoty jejího z-indexu tak, aby překryla veškeré ostatní objekty na plátně a bylo možné s adorner vrstvou komfortně pracovat. 
		
		\subsubsection{Vizualizace vztahů}
		Práce se samotnými vztahy probíhá opět na úrovni viewmodelu. Podobně jako je tomu u tabulek, nicméně samotný vztah nyní není reprezentován jediným objektem na plátně, ale objektů se zde vyskytuje celá řada. 
		
		\paragraph{Reprezentace vztahů pomocí lomených čar}
		Vztah je reprezentován lomenou čárou. Na obou koncích této čáry se nachází symboly vyjadřující kardinalitu a povinnost. Na obrázku \ref{fig:screenPolyline} vidíme ukázku lomené čáry spojující dvě tabulky. Tato lomená čára je reprezentována seznamem segmentů, kde sousední segmenty svírají vždy pravý úhel. V grafickém editoru je použita vlastní implementace lomené čáry, protože třída \texttt{Polyline}, která je pro práci s lomenými čárami určená, nabízí velmi omezené možnosti interakce ze strany uživatele a hodí se tedy spíše pro pouhou vizualizaci dat např. formou grafu.
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.74\textwidth]{Figures/ScreenPolyline}
			\caption{Vizualizace vztahu mezi dvěma tabulkami}
			\label{fig:screenPolyline}
		\end{figure}
		
		\paragraph{Interakce s lomenými čárami}
		Závislosti mezi třídami pro vizualizaci vztahů popisuje třídní diagram \ref{fig:classDiagMovePolyline}. Viewmodel pro vztah obsahuje kolekci lomových bodů čáry, společně s kolekcí čar, které tvoří jednotlivé segmenty lomené čáry. V první fázi konstrukce lomené čáry jsou segmenty vytvořeny na základě lomových bodů, které jsou po přidání nového vztahu určeny algoritmem pro vyhledání trasy. Detailní popis algoritmu nalezneme v kapitole \ref{secAStar}. Editor reaguje na události vyvolané při práci s kolekcí čar tak, aby byla zajištěna integrita dat viewmodelu s objekty na plátně. 
		
		\begin{figure}[!h]
			\centering
			\includegraphics[width=0.74\textwidth]{Figures/EditorVztahy}
			\caption{Část třídního diagramu - vizualizace vztahu mezi tabulkami}
			\label{fig:classDiagMovePolyline}
		\end{figure}
		
		Všechny segmenty lomené čáry reagují na interakci pomocí myši. Pro přenos informací o~provedených změnách do viewmodelu je využit návrhový vzor Pozorovatel, který využívá pro tuto činnost události. Viewmodel vztahu je informován o průběhu interakce, tím je tedy možné provádět aktualizaci pozice přilehlých segmentů lomené čáry včetně ukončujících symbolů v závislosti na pohybu určitého segmentu. Po ukončení interakce je opět vyvolána událost, která spustí post-processing, jehož součástí je např. spojení stejně orientovaných segmentů čáry lišících se pozicí v rámci tolerance nebo změna orientace ukončujících symbolů na základě orientace krajních segmentů čáry.
		
	\subsection{Vyhledání trasy po přidání vztahu} \label{secAStar}
	Po přidání nového vztahu mezi tabulkami je nutné tento vztah vykreslit na plátno. Tento krok byl v první fázi vývoje nástroje implementován metodou, která nejdříve zjistila vzájemnou polohu obou tabulek a následně vztah vykreslila jako spojnici předefinovaných lomových bodů. Ukázku této situace vidíme na obrázku \ref{fig:screenLinesOverlay}. Tento způsob se neosvědčil když tabulka figurovala v několika vztazích, protože často docházelo k překrývaní čar. Největším problémem tohoto řešení byl fakt, že nejsou zohledněny další tabulky na plátně a dochází ke křížení vztahů s tabulkami, které se vyskytují v předdefinované trase. Z toho důvodu je diagram transformován na graf a problém je řešen jako vyhledávání cesty v grafu.
	
	\begin{figure}[!h]
		\centering
		\includegraphics[width=0.75\textwidth]{Figures/ScreenLineOverSelf}
		\caption{Ukázka překrytí lomených čar}
		\label{fig:screenLinesOverlay}
	\end{figure}
	
	\subsubsection{Sestavení grafu} \label{secCreateGraph}
	Prvním krokem při hledání vhodné trasy pro vztah je převod plátna na graf. Vrcholy grafu jsou tvořeny obrazovými body plátna. Mezi vrcholy existuje hrana pokud se jedná o sousední obrazové body. Nejprve bylo nutné převést každý obrazový bod na samostatný uzel grafu. Tento uzel obsahuje souřadnice bodu na plátně, společně s informací zda je bod volný nebo jej překrývá tabulka. Výhodou této reprezentace je její přesnost, kdy nedochází k zanedbání informací z plátna. Problémem je ovšem negativní dopad na výkon nástroje, protože pro plátno o šířce a výšce 4000 obrazových bodů je nutné alokovat 16 milionů uzlů, které v průměru zabírají více než 1GB operační paměti. Počet uzlů grafu je nutné zredukovat tak, aby zabíraly řádově méně prostoru operační paměti. Z tohoto důvodu je plátno nejprve rozděleno na čtvercové úseky o~konstantních rozměrech. Pokud tabulka alespoň částečně zasahuje do některého z úseku, je úsek označen jako obsazený. Z této mřížky je následně vytvořen graf, který místo 16 milionů uzlů jich pro dříve zmíněné rozměry obsahuje pouze 1600. Alokace operační paměti v tomto případě trvá jen několik milisekund a zabraná paměť se pohybuje řádově v jednotkách MB.
	
	\subsubsection{Vyhledávání cesty v grafu}
	Tento problém je v práci řešen dvěma algoritmy: prohledávání do šířky a A*. Vstupem obou algoritmů je prohledávány graf, počáteční a cílový vrchol. Výstupem je kolekce uzlů reprezentující nalezenou cestu. Dle této kolekce je možné sestavit vztah (viz obrázek \ref{fig:classDiagMovePolyline}).
	
	\paragraph{Prohledávání grafu průchodem do šířky}
	Princip prohledávání popisuje algoritmus \ref{alg:bfs}. Prohledávání grafu do šířky využívá pro svou činnost frontu. V každém kroku jsou do fronty přidány sousední volné uzly vzhledem k aktuálně zpracovávanému uzlu. Pokud je tento uzel cílovým, prohledávání končí a cesta je nalezena. Pokud dojde k vyprázdnění fronty aniž by byl nalezen cíl, tak cesta v grafu neexistuje. Funkce \texttt{VystopovatCestu} slouží pro následování ukazatelů na rodičovské uzly pro vytvoření kolekce uzlů v nalezené cestě. Tento způsob hledání trasy je velmi snadno implementovatelný, jeho výkon bohužel není ideální, protože vyhledávání trvá řádově desítky až stovky milisekund pro jedinou trasu. \\
	
	\begin{algorithm}[H]
		\SetKwInOut{Input}{Vstup}
		\SetKwInOut{Output}{Výstup}
		
		\SetKwData{Closed}{uzavřené\_uzly}
		\SetKwData{Open}{otevřené\_uzly}
		\SetKwData{Current}{aktuální\_uzel}
		\SetKwData{Result}{výsledek}
		\SetKwData{N}{U}
		
		\SetKwFunction{BacktrackNodes}{VystopovatCestu}
		\SetKwFunction{Add}{Přidat}
		\SetKwFunction{Enqueue}{ZařaditPoložku}
		\SetKwFunction{Dequeue}{VybratPoložku}
		
		\Input{Graf $G$, Počáteční vrchol $S$, Cílový vrchol $E$}
		\Output{Cesta ve formě kolekce uzlů}
		\BlankLine
		
		\Closed $\leftarrow$ prázdná množina\;
		\Open $\leftarrow$ prázdná fronta\;
		\Open.\Enqueue{$S$}\;
		\While{\Open obsahuje prvky}{
			\Current $\leftarrow$ \Open.\Dequeue{}\;
			\Closed.\Add{\Current}\;
			\If{\Current == $E$}{
				\Result $\leftarrow$ \BacktrackNodes{\Current}\;
			}
		
			\ForEach{uzel \N který je sousední s \Current}{
				\If{\N není obsažen v \Closed}{
					\N.Parent $\leftarrow$ \Current\;
					\Open.\Enqueue{\N}\;
				}
			}
		}
		\caption{Prohledávání grafu průchodem do šířky}
		\label{alg:bfs}
	\end{algorithm}
	
	\paragraph{Prohledávání grafu algoritmem A*}
	Druhým implementovaným algoritmem je A* \cite{aStar}, používaný k nalezení nejkratší cesty v grafu. Tento algoritmus kombinuje výhody hladového BFS a Djikstrova algoritmu \cite{aStar}. Priorita prohledávání uzlů je určena na základě heuristiky, která slouží k odhadu vzdálenosti z aktuálního uzlu k cíli. Metod jak tuto hodnotu určit je několik, její volba závisí na reprezentaci prohledávaného prostoru a možných směrech. Pro mřížku se 4-mi směry pohybu je nejvhodnější metoda Manhattan (viz vztah \ref{eq:manhattan}). Metoda Manhattan odhaduje vzdálenost z aktuálního uzlu k cíli jako součet absolutních hodnot vertikálního a horizontálního rozdílu bodů.
	
	\begin{equation}
		H = \mid aktualni.x - cilovy.x \mid + \mid aktualni.y - cilovy.y \mid
		\label{eq:manhattan}
	\end{equation}
	
	Uzly jsou uchovány v prioritní frontě \cite{queue}, priorita je určena hodnotou vypočtenou pomocí metody Manhattan (viz vztah \ref{eq:manhattan}). Možností implementace prioritní fronty je celá řada, pro tento účel bylo nejvhodnější použít binární haldu, pro co nejlepší výkon algoritmu. Jedná se o stromovou strukturu, kde prvek s nejvyšší prioritou nalezneme v kořeni stromu. Otevřené knihovny bohužel obvykle neimplementují operaci pro aktualizaci priority, která vyvolá nutnost úpravy stromové struktury. V nástroji bylo tedy nutné tuto strukturu pro správnou funkci A* algoritmu implementovat také. 
	
	\begin{algorithm}[!h]
		\SetKwInOut{Input}{Vstup}
		\SetKwInOut{Output}{Výstup}
		
		\SetKwData{Closed}{uzavřené\_uzly}
		\SetKwData{Open}{otevřené\_uzly}
		\SetKwData{Current}{aktuální\_uzel}
		\SetKwData{Result}{výsledek}
		\SetKwData{N}{U}
		
		\SetKwFunction{BacktrackNodes}{VystopovatCestu}
		\SetKwFunction{Add}{Přidat}
		\SetKwFunction{Enqueue}{ZařaditPoložku}
		\SetKwFunction{Dequeue}{VybratPoložku}
		\SetKwFunction{Update}{AktualizovatPrioritu}
		\SetKwFunction{Manhattan}{Manhattan}
		
		\Input{Graf $G$, Počáteční vrchol $S$, Cílový vrchol $E$}
		\Output{Cesta ve formě kolekce uzlů}
		\BlankLine
		
		\Closed $\leftarrow$ prázdná množina\;
		\Open $\leftarrow$ prázdná prioritní fronta\;
		\Open.\Enqueue{$S$}\;
		\While{\Open obsahuje prvky}{
			\Current $\leftarrow$ \Open.\Dequeue{}\;
			\Closed.\Add{\Current}\;
			\If{\Current == $E$}{
				\Result $\leftarrow$ \BacktrackNodes{\Current}\;
			}
			
			\ForEach{uzel \N který je sousední s \Current}{
				\If{\N je obsažen v \Closed or \N je překážka}{
					\texttt{\textbf{continue\;}}
				}
				
				\N.Rodič $\leftarrow$ \Current\;
				\N.Manhattan $\leftarrow$ \Manhattan{\N, $E$}\;
				
				\If{\N není obsažen v \Open}{
					\Open.\Enqueue{\N}\;
					\texttt{\textbf{continue\;}}
				}
			
				\Open.\Update{\N}\;
			}
		}
		\caption{Prohledávání grafu algoritmem A*}
		\label{alg:astar}
	\end{algorithm}
	
	Algoritmus \ref{alg:astar} demonstruje princip A*. Ten spočívá v použití prioritní fronty pro ještě nezpracované uzly a množiny pro uzly zpracované. Algoritmus v každém kroku vezme z fronty nezpracovaných uzlů uzel s nejvyšší prioritou. Pokud je zpracovávaný uzel cílový, prohledávání končí. V opačném případě je uzel vložen do množiny zpracovaných uzlů, pro sousední uzly je určena priorita, ukazatel na rodiče je nastaven na aktuální uzel a tyto uzly jsou vloženy do množiny nezpracovaných uzlů. Po nalezení cíle je nutné následovat ukazatele na rodiče každého uzlu pro rekonstrukci nalezené cesty. 
	
	\subsection{Automatické rozvržení tabulek} \label{secTablePos}
	Přidávání již existujících tabulek v databázi je možné dvěma způsoby: automaticky nebo metodou drag and drop. Drag and drop umožňuje přesně určit pozici přidané tabulky v diagramu. Ovšem pokud je nutné přidat větší množství tabulek, stává se tento způsob poněkud nepraktickým. Z toho důvodu je zde možnost zvolit pozici tabulky na plátně automaticky. Implementace využívá grafové reprezentace, stejně jako výpočet trasy. Tabulky se rozmísťují kolem středu plátna bez vzájemného překrývání. 
		
	\subsubsection{Sestavení a příprava grafu}
	Algoritmus pro rozvržení tabulek na plátno, aniž by došlo k jejich překrytí, využívá opět reprezentaci plátna pomocí mřížky, stejně jako tomu je u vyhledávání trasy (viz kapitola \ref{secCreateGraph}). Převod na graf ovšem není pro správnou funkci vysloveně nutný, celý postup by bylo možné realizovat pomocí matice obsahující jen čísla.
	
	\begin{algorithm}[!h]
		\SetKwInOut{Input}{Vstup}
		\SetKwInOut{Output}{Výstup}
		
		\SetKwData{Counter}{čítač}
		\SetKwData{Current}{aktuální\_prvek}
		\SetKwData{Grid}{G}
				
		\Input{Mřížka $G$, Šířka mřížky $W$, Výška mřížky $H$}
		\Output{Předzpracovaná mřížka $G$ pro vyhledávání volných obdélníků}
		\BlankLine
		
		\For{$i \leftarrow 0$ \KwTo $W-1$}{
			\Counter $\leftarrow$ 1\;
			\For{$j \leftarrow H-1$ \KwTo 0}{
				\Current $\leftarrow \Grid\left[ i, j \right]$\;
				\If{\Current je překážkou}{
					\Counter $\leftarrow$ 1\;
					\texttt{\textbf{continue\;}}
				}
				\Current.Metrika $\leftarrow$ \Counter\;
				\Counter $\leftarrow \Counter+1$\;
			}
		}
		
		\caption{Příprava mřížky pro vyhledávání}
		\label{alg:preprocessGrid}
	\end{algorithm}

	Před samotným vyhledáváním volné pozice je nutné provést přípravu dat v mřížce. Postup přípravy mřížky demonstruje algoritmus \ref{alg:preprocessGrid}. Mřížku je nutné projít nejprve po sloupcích, vždy směrem vzhůru pro jednotlivé sloupce, a každou volnou buňku opatřit číslem vyjadřujícím její vzdálenost od nejbližší nižší překážky. Začínáme číslem 1, počítadlo zvyšujeme s každou volnou buňkou ve sloupci, pokud narazíme na překážku, počítadlo opět nastavíme na počáteční hodnotu. 
	
	\subsubsection{Nalezení volné pozice}
	V připravené mřížce je nyní možné vyhledávat volné obdélníky. Proces hledání popisuje algoritmus \ref{alg:findFreeRect}, vstupem je připravená mřížka a minimální rozměry volné plochy, výstupem je souřadnice levého horního rohu tabulky pro umístění do volné plochy. Mřížku procházíme po řádcích zleva a hledáme posloupnost čísel v řádku, pro která platí, že všechny z nich jsou rovny nebo vyšší minimální výšce hledané plochy. Počet takových čísel v řádku musí být roven nebo vyšší než je minimální šířka hledané plochy. Nyní zbývá pouze zvolit jednu z nalezených volných ploch. Pro tento účel byla opět zvolena metoda Manhattan (viz vztah \ref{eq:manhattan}) k určení metriky levého horního bodu obdélníkové plochy vzhledem ke středu plátna. Bod s hodnotou metriky lepší než je průměrná hodnota je zvolen jako výsledný počáteční bod hledaného obdélníku. 
	
		\begin{algorithm}[!h]
		\SetKwInOut{Input}{Vstup}
		\SetKwInOut{Output}{Výstup}
		
		\SetKwData{Nodes}{buňky}
		\SetKwData{Current}{aktuální\_buňka}
		\SetKwData{Result}{výsledek}
		\SetKwData{Line}{linie}
		\SetKwData{Grid}{G}
		\SetKwData{Cell}{C}
		\SetKwData{Node}{U}
		\SetKwData{Avg}{průměr}
		
		\SetKwFunction{Add}{Přídat}
		 \SetKwFunction{Manhattan}{Manhattan}
		
		\Input{Mřížka $G$, Šířka mřížky $W$, Výška mřížky $H$, Minimální šířka $MW$, Minimální výška $MH$}
		\Output{Levý horní roh volného obdélníku}
		\BlankLine
		
		\Nodes $\leftarrow$ prázdná kolekce\;
		\For{$i \leftarrow 0$ \KwTo $H-1$}{
			\For{$j \leftarrow 0$ \KwTo $W-1$}{
				\Current $\leftarrow \Grid\left[ i, j \right]$\;
				\Line $\leftarrow$ prázdná kolekce\;
				\For{$k \leftarrow j$ \KwTo $j + MW - 1$}{
					\Line.\Add{$\Grid\left[ k, j \right]$}
				}
				\If{$\forall c \in \Line ~ c.Metrika >= MH$ and c je volná}{
					\Nodes.\Add{\Current}\;
				}
			}
		}
		\lForEach{prvek \Node z \Nodes}{vypočítat \Manhattan{\Node, střed}}
		\Result $\leftarrow$ buňka, kde \Manhattan{buňka, střed} < průměrná hodnota\;
		\caption{Nalezení volné plochy o minimálních rozměrech}
		\label{alg:findFreeRect}
	\end{algorithm}

	\subsection{Export diagramů}
	Grafickou podobu diagramu je možné exportovat ve formátu PNG a XPS. Pokud uložíme diagram do PNG, není nutné exportovat celé plátno, ale jen využitou plochu. Ve formátu XPS dojde k exportu celého plátna, nicméně tento typ exportu je velmi rychlý z důvodu vektorové reprezentace plátna ve WPF aplikacích. Nástroj umožňuje také tvorbu DDL skriptu pro objekty v diagramu, tato volba je využitelná v kombinaci s dalšími nástroji, které umožňují použít DDL skript jako jeden z možných formátů pro import.
		
\newpage
\section{Návrh a implementace datové vrstvy}
Grafický editor nabízí mnoho operací pro úpravu relačního schématu skrze GUI. Pro provedení těchto akcí je nutné nejprve sestavit validní DML příkaz, který změnu ve schématu provede. Nástroj aktuálně podporuje dva SŘBD: Oracle Database a Microsoft SQL Server. Navzdory tomu, že SQL je standardizované, syntaxe některých příkazů se liší. Z důvodů těchto odlišností bylo potřeba navrhnout způsob synchronizace s relačním schématem tak, aby změny provedené v diagramu mohly být promítnuty do relačního schématu pomocí jednotného rozhraní. Datová vrstva je navrhnuta s ohledem na možné budoucí rozšíření o další SŘBD.
	
	\subsection{Zdroj informací o relačním schématu} \label{secDataSource}
	Informace o podobě relačního schématu nalezneme v tzv. systémovém katalogu. Systémový katalog je souhrn tabulek, které uchovávají metadata popisující strukturu databáze, nalezneme zde informace o veškerých databázových objektech. Pro uživatele je zpřístupněn systémový katalog pouze pro čtení použitím pohledů nad samotnými tabulkami. Pokud chceme upravovat strukturu databáze, je nutné využít DDL příkazů. Systémový katalog jednotlivých SŘBD nabízí podobné možnosti, ale struktura a názvy pohledů se mohou lišit. Přístup k systémovému katalogu je implementován pomocí vlastních SQL příkazů. Pro tuto činnost tedy nejsou využity externí knihovny.
	
  		\subsubsection{Systémový katalog Microsoft SQL Server}
  		Pohledy nad systémovými tabulkami jsou součástí schématu \texttt{sys}. V aplikaci se pracuje pouze s~některými z těchto pohledů. Pro zjištění často používaných informací jsou zde implementovány uložené procedury, které práci značně ulehčují. Pro zjištění informací o primárním klíči tabulky je možné použít proceduru \texttt{sp\_pkeys}, pro cizí klíče existuje procedura \texttt{sp\_fkeys}. V aplikaci se pracuje s těmito pohledy: 
  		
  		\begin{itemize}
  			\item \texttt{databases} - Pohled obsahuje informace o databázích.
  			\item \texttt{tables} - Tento pohled slouží pro zjištění informací o tabulkách, jako je např. název a~identifikátor.
  			\item \texttt{columns} - Zde zjistíme informace o sloupcích tabulky. Často se používá v kombinaci s~pohledem \texttt{types}.
  			\item \texttt{types} - Tento pohled obsahuje informace o datových typech.
  			\item \texttt{foreign\_keys} - Pohled obsahuje informace o cizích klíčích.
  		\end{itemize}
  		
  		\subsubsection{Systémový katalog Oracle Database}
  		Tabulky a pohledy systémového katalog jsou vlastněny uživatelem \texttt{SYS}. Oracle Database rozlišuje tři typy pohledů, pomocí těchto prefixů:
  		
  		\begin{itemize}
  			\item \texttt{USER} - Pohledu uvozeny tímto prefixem obsahují informace o objektech, které vlastní přihlášený uživatel.
  			\item \texttt{ALL} - Tyto pohledy obsahují veškeré objekty, ke kterým má přihlášený uživatel přístup, nemusí být jejich vlastníkem.
  			\item \texttt{DBA} - Zde nalezneme informace o veškerých objektech databáze. Pohledy uvozeny tímto prefixem mohou obsahovat detailnější informace.
  		\end{itemize} 
	
		V nástroji jsou jako zdroj informací použity pohledy uvozené prefixem \texttt{ALL}. Pro získání informací o schématu databáze jsou použity tyto pohledy:
		
		\begin{itemize}
			\item \texttt{ALL\_OBJECTS} - Pohled slouží k získání informací o veškerých objektech, které jsou uživateli přístupné. Používá se pro zjištění informací o tabulkách.
			\item \texttt{ALL\_TAB\_COLUMNS} - Tento pohled slouží pro zjištění informací o sloupcích tabulky včetně informací o datovém typu.
			\item \texttt{ALL\_CONSTRAINTS} - Zde zjistíme informace o integritních omezeních.
			\item \texttt{ALL\_CONS\_COLUMNS} - Tento pohled obsahuje informace o sloupcích, které figurují v integritních omezeních.
			\item \texttt{FOREIGN\_KEYS} - Pohled obsahuje informace o integritních omezeních v podobě cizího klíče.
		\end{itemize}
		
		
	\subsection{Struktura datové vrstvy}
	Strukturu datové vrstvy popisuje diagram na obrázku \ref{fig:classDiagSync}. Jádrem datové vrstvy jsou třídy \texttt{MsSqlMapper} a \texttt{OracleMapper}. Tyto třídy (tzv. \emph{mappery}) realizují sestavení DML příkazů pro úpravu schématu, stejně tak jsou zodpovědné za přístup k datům systémového katalogu. Připojení k databázi realizují třídy \texttt{OracleDatabase} a \texttt{MsSqlDatabase}, tyto třídy nabízejí jednotné rozhraní. 
	
	\begin{figure}[H]
		\centering
		\includegraphics[width=0.70\textwidth]{Figures/EditorSync}
		\caption{Část třídního diagramu - struktura datové vrstvy}
		\label{fig:classDiagSync}
	\end{figure}
	
	V nástroji se obvykle nepřistupuje k mapperům přímo, ale kvůli nutnosti přípravy dat před některými operacemi v závislosti na SŘBD, se kterým aktuálně pracujeme, je přístup zapouzdřen pomocí návrhového vzoru Strategy. Strategie (třídy implementující rozhraní \texttt{IDatabaseStrategy}) představuje primární rozhraní přístupu k mapperům pro provedení změn v relačním schématu. Každému mapperu odpovídá samostatná strategie, kontext je definován typem aktuální relace ve třídě \texttt{DatabaseContext}. Struktura se samostatnými strategiemi pro jednotlivé mappery je zvolena z důvodu nutného předzpracování dat v případě některých operací. Pokud by k tomuto jevu nedocházelo, bylo by možné namísto strategie použít vzor Factory a s data mappery pracovat přímo. 
	
	Datová vrstva je využívaná v doménové logice prostřednictvím třídy \texttt{DatabaseUpdater}. \texttt{DatabaseUpdater} pracuje se strategiemi pomocí třídy \texttt{DatabaseContext}. Nejprve je nutné strategii zvolit pomocí metody \texttt{SetStrategy} ve třídě \texttt{DatabaseContext}, poté může následovat volání metod, které jsou strategiemi vykonávány (viz kapitola \ref{secDbUpdate}). Informace o relaci uchovává třída \texttt{SessionProvider}, která je třídou \texttt{DatabaseUpdater} využívána. Toto uspořádání tříd pro provádění změn v relačním schématu eliminuje nutnost rozhodovacích bloků při každém volání metody data mapperu, stejně tak nabízí snadný způsob rozšíření nástroje o nové SŘBD. Stačí pouze přidat nový data mapper, který implementuje požadované rozhraní a vytvořit pro něj novou strategii.
	
%		\subsubsection{Použité návrhové vzory}
%		V této kapitole je popsána funkce návrhových vzorů, které jsou pro funkcionalitu datové vrstvy zásadní. První dva z nich jsou využity v datové vrstvě, další jsou použity pro propojení datové vrstvy s doménovou logikou. U všech vzorů je také uveden konkrétní účel jeho použití v nástroji.
%			
%			\paragraph{Data Mapper}
%			Tento vzor slouží pro zprostředkování komunikace mezi vzájemně nezávislými systémy. Data mapper je často používán v případech, kdy potřebujeme přistupovat k různým datovým zdrojům s odlišným rozhraním. Typ datového zdroje je sice jeden, tedy systémový katalog relační databáze, nicméně pro různé SŘBD se katalogy liší, což představuje ideální situaci pro použití tohoto vzoru. Další výhodou je i nezávislost podoby dat ve zdroji a doménové vrstvě, tímto je tedy možné reprezentovat data pro grafický editor jednotným modelem nezávisle na struktuře systémového katalogu.
%			
%			\paragraph{Layer Supertype} \label{secSupertype}
%			Layer Supertype slouží k sjednocení společného chování určité skupiny objektů nebo celé vrstvy, výhodou je zamezení duplikace metod se stejnou signaturou. Tento vzor je využit v datové vrstvě na dvou místech. Prvním použitím je definice rozhraní pro třídy zodpovědné za přístup k databázi, zde jsou definovány základní metody pro otevření nového připojení a jeho uzavření.  Druhým použitím je sjednocení operací pro data mappery. Vrstva definuje operace, které musí umět příslušný data mapper vykonávat, aby jej bylo možné použít pro komunikaci grafického editoru se SŘBD. Jak již bylo zmíněno, SŘBD se svými funkcemi liší, takže tato vrstva nedeklaruje všechny dostupné operace, ale spíše nezbytný základ pro použití v nástroji. Každý data mapper obsahuje navíc ještě operace specifické pro SŘBD, se kterým komunikuje, ale ty už součásti supertypu nejsou.
%
%			\paragraph{Strategy} \label{secStrategy}
%			Strategie je jedním z kategorie návrhových vzorů chování a slouží k definici skupiny tříd, které obvykle řeší stejný problém, ale jejich implementace se liší. Cílem tohoto vzoru je tuto skupinu tříd zastřešit společným rozhraním a umožnit záměnu těchto tříd v závislosti na situaci, ve které je provedení operace požadováno. Jádrem je třída pro udržování kontextu, která nabízí rozhraní pro nabízené operace. Na základě specifikovaného kontextu je vybraná strategie, která operaci provede. Jednotlivé strategie nabízejí jednotné rozhraní, což umožňuje v třídě pro kontext pracovat se strategiemi na úrovni supertypu. Tímto způsobem se vyhneme rozhodovacímu bloku v situacích, kdy je implementace závislá na SŘBD.
%			
%			\paragraph{Singleton}
%			Návrhový vzor singleton je vhodné použít v situaci, kdy potřebujeme ke stejné instanci objektu přistupovat z více míst aplikace. V nástroji je tento vzor využíván pro uchovávání a zprostředkování informací o aktuální relaci. 
	
	\subsection{Sestavení aktuální relace}
	Informace nutné pro připojení k databázi se částečně liší pro různé SŘBD. Pro vytvoření relace je nutné zkonstruovat řetězec pro připojení na základě přihlašovacích údajů. Za tuto činnost je zodpovědná třída \texttt{SessionProvider} (viz obrázek \ref{fig:classDiagSync}). Kromě údajů potřebných k úspěšné autentizaci je zde uveden také SŘBD, ke kterému jsme v aktuální relaci připojeni. Tato informace je zásadní pro konstrukci řetězce s přihlašovacími údaji k serveru, protože ty se liší pro každý SŘBD. Stejně tak se liší i třídy pro jeho sestavení z uvedených informací. Standardně jsou přihlašovacími údaje zadávány pomocí GUI (viz obrázek \ref{fig:screenAuthGui}), nicméně může dojít k situaci, kdy potřebujeme využít parametry, které GUI nenabízí (viz obrázek \ref{fig:screenAuthConnStr}). V tomto případě je možné zadat řetězec vlastní a třída \texttt{SessionProvider} s informacemi o relaci zprostředkovává tento řetězec pro připojení, aniž by jej bylo nutné sestavovat, jako je tomu v předchozím případě.
	
	\begin{figure}[!h]
		\centering
		\subfloat[Dialog pro nastavení relace]
		{
			\includegraphics[width=0.2\textwidth]{Figures/ScreenConnect}
			\label{fig:screenAuthGui}
		}
		\qquad
		\subfloat[Dialog pro zadání vlastního řetězce pro připojení]
		{
			\includegraphics[width=0.7\textwidth]{Figures/ScreenConnectConnString}
			\label{fig:screenAuthConnStr}
		}
		\caption{Zadání přihlašovacích údajů}
	\end{figure}
	
	\subsection{Synchronizace s relačním schématem}
	Aktualizace existujícího schématu je prováděna okamžitě po provedení změny v ER diagramu. Nevyužívá se tedy odložená aktualizace, jako u většiny testovaných nástrojů. Nástroj podporuje práci se schématem použitím několika diagramů současně, není nutné diagram generovat pro všechny tabulky, ale stačí přidat ty, se kterými potřebujeme pracovat. Tento způsob je výhodný pro rozsáhlá schémata, kde rozdělení schématu na určité logické celky zpřehlední vizualizaci a~usnadní tak proces aktualizace. Okamžité provedení aktualizace je důležité právě z důvodu práce s několika diagramy najednou. Jinak by mohlo dojít k situaci, kdy pro provedení změn záleží na pořadí jejich potvrzení, což může mít za následek nemožnost vykonání některých z~nich, jako je tomu např. v nástroji Microsoft SQL Server Management studio. 
	
		\subsubsection{Problém odložené aktualizace}
		K problémům s odloženou aktualizace zpravidla dochází vlivem konfliktu integritních omezení nebo odstraněním atributu. Příklad takového problému vidíme v tabulce \ref{tab:lateUpdateIssue}.
				
		\begin{table}[!h]
			\centering
			\caption{Příklad problému odložené aktualizace}
			\label{tab:lateUpdateIssue}
			\begin{tabular}{l l l}
				\toprule
				Čas & Diagram 1 & Diagram 2 \\
				\midrule
				\texttt{t1} & Povolení \texttt{NULL} hodnot atributu \texttt{X} & \\
				\texttt{t2} & & Nastavení atributu \texttt{X} primárním klíčem \\
				\texttt{t3} & & Potvrzení změny \\
				\texttt{t4} & Změnu není možné potvrdit & \\
				\midrule
			\end{tabular}
		\end{table}
		
		V čase \texttt{t4} není možné změnu potvrdit, diagram 1 navíc není v souladu s existujícím schématem. Odstranění problému závisí na možnostech použitého nástroje.
		
		\subsubsection{Aktualizace schématu} \label{secDbUpdate}
		Celý proces aktualizace schématu začíná provedením změny v diagramu pomocí grafického editoru. Po potvrzení změny uživatelem je nutné provést adekvátní SQL příkaz. Sekvenční diagram na obrázku \ref{fig:seqRemoveFk} zachycuje odstranění vztahu mezi tabulkami z pohledu datové vrstvy. Na základě SŘBD (informaci poskytuje třída \texttt{SessionProvider}), se kterým aktuálně pracujeme, je zvolen data mapper, který příkaz provede. Ten je zodpovědný i za sestavení SQL příkazu. Operace data mapperu je volána prostřednictvím rozhraní třídy \texttt{DatabaseContext}, který vybere konkrétní strategii pro práci s příslušným data mapperem. 
		
		\begin{figure}[H]
			\centering
			\includegraphics[width=0.7\textwidth]{Figures/SequenceRemoveFkHiRes}
			\caption{Sekvenční diagram - odstranění vztahu}
			\label{fig:seqRemoveFk}
		\end{figure}
		
		Při vykonávání příkazu může samozřejmě dojít k chybě, ta může být zaviněna jak chybou vstupu na straně uživatele, tak např. chybou sítě. Tyto chyby vyvolávají výjimky v kódu, proto probíhá přístup k metodám třídy \texttt{DatabaseContext} přes třídu \texttt{DatabaseUpdater}. Tato třída má na starosti zachycení výjimek. O chybách je uživatel informován formou dialogového okna a také jsou zapsány do logu, který se nachází v samostatném panelu. Do tohoto logu jsou vypisovány také prováděné SQL příkazy pro snazší identifikaci chyb, pokud změna neproběhla úspěšně. V~případě chyby je nutné diagram uvést do původního stavu. Pokud se jedná o chybu při úpravě struktury tabulky, dojde k aktualizaci dat doménové vrstvy opětovným načtením hodnot ze systémového katalogu. Pokud dojde k chybě při provádění operace, která způsobuje odstranění nebo přidání objektu na plátno, není opětovné načtení dat potřeba, protože k operacím s objekty na plátně dochází jen po úspěšném dokončení operace.
	
	\subsection{Serializace diagramů}
	Nástroj podporuje ukládání rozpracovaných diagramů přímo do speciální tabulky v databázi, ke které se diagram vztahuje. Oproti klasickému ukládání na pevný disk ve formě souboru umožňuje tento způsob zpřístupnění diagramu dalším osobám pracujícím s databázi, aniž by bylo nutné přenášet soubory projektu. Navíc je možné pokračovat v práci z jiného počítače, protože je potřeba jen připojení k~databázi, kde se diagram nachází. Výhodou je také zálohování, protože diagramy je možné zálohovat v rámci záloh databáze. Strukturu tabulky pro Microsoft SQL Server zachycuje obrázek \ref{fig:serializeMsSql}, pro Oracle Database pak obrázek \ref{fig:serializeOracle}.
	
	\begin{figure}[!h]
		\centering
		\subfloat[Tabulka v Microsoft SQL Server]
		{
			\includegraphics[width=0.4\textwidth]{Figures/SerializeTableMsSql}
			\label{fig:serializeMsSql}
		}
		\qquad
		\subfloat[Tabulka v Oracle Database]
		{
			\includegraphics[width=0.4\textwidth]{Figures/SerializeTableOracle}
			\label{fig:serializeOracle}
		}
		\caption{Struktura tabulky pro ukládání diagramů}
	\end{figure}
		
		\subsubsection{Uložení diagramu}
		Serializace diagramu probíhá na úrovni viewmodelů, protože ty obsahují veškerá potřebná data týkající se struktury diagramu. Serializaci podléhají veškeré vlastnosti diagramu, které nelze získat z existujícího schématu. Jedná se tedy o souřadnice objektů na plátně, jejich velikost a samozřejmě také názvy a identifikátory, aby bylo možné provést načtení příslušných polí ze systémového katalogu. Tato struktura je uložená ve formátu XML. Příklad serializovaného vztahu ve formě XML elementu vidíme na výpisu kódu \ref{src:xmlFk}.
		
		\begin{lstlisting}[language=xml,label=src:xmlFk,caption=Serializovaný vztah ve formátu XML]
		<ConnectionInfoViewModel SourceConnectorOrientation="Down" DestinationConnectorOrientation="Down">
			<RelationshipModel Id="661577395" Name="Objednany_zajezd_Zajezd_FK" LastModified="2017-01-21T15:17:53.68">
				<Source>
					<TableModel Title="Zajezd" Id="453576654" />
				</Source>
				<Destination>
					<TableModel Title="Objednany_zajezd" Id="421576540" />
				</Destination>
			</RelationshipModel>
			<Points>
				<ConnectionPoint X="1060" Y="1173" />
				<ConnectionPoint X="1060" Y="1200" />
				<ConnectionPoint X="1500" Y="1200" />
				<ConnectionPoint X="1500" Y="832" />
			</Points>
		</ConnectionInfoViewModel>
		\end{lstlisting}
		
		\subsubsection{Načtení diagramu}
		Načtení diagramu je rozděleno na dvě fáze. V první fázi je nutné provést kontrolu existence objektů v databázi, aby se nezobrazovaly již neexistující tabulky nebo integritní omezení v~podobě cizích klíčů, po této kontrole jsou načtena data ze systémového katalogu. Tímto je zamezeno nekonzistenci načteného diagramu a relačního schématu, stejný princip je využit i při změně aktivního diagramu při práci s několika diagramy zároveň, aby zobrazený diagram ukazoval aktuální podobu schématu. V druhé fázi je potřeba přidat objekty na plátno a nastavit jim požadované vlastnosti tak, aby byla struktura načteného diagramu stejná jako při ukládání.

\newpage
\section{Závěr}
Cílem této práce bylo vytvořit aplikaci umožňující návrh schématu relační databáze formou ER diagramu, která je schopna pracovat s SŘBD Microsoft SQL Server a Oracle Database. Práce je rozdělené na dvě části, první část se zaměřuje na problematiku notací ER diagramů z hlediska využívaných konstrukčních prvků, jejich rozdílů a využití samotných ER diagramů společně s~nevýhodami. Součástí první části práce je také porovnání existujících nástrojů pro návrh relačního schématu databáze, nástroje jsou porovnány nejen na základě možností grafického editoru pro práci s ER diagramy, ale porovnání se zaměřuje také na oblast synchronizace diagramu s existujícím relačních schématem.

Druhá část bakalářské práce se zabývá návrhem a implementací grafického editoru vyvíjeného nástroje, včetně synchronizace diagramů s relačním schématem. V práci je detailně popsáno fungování klíčových částí grafického editoru pro práci s ER digramy, včetně problematiky algoritmizace některých činností. Datová vrstva pro přístup k systémovému katalogu SŘBD je navržena s ohledem na možná budoucí rozšíření o podporu dalších SŘBD. Návrh obou částí je doplněn o~části třídního diagramu umožňující snazší popis struktury těchto částí.

V rámci implementace jsem narazil na několik problémů souvisejících s limitujícím výkonem WPF aplikací, nicméně se tyto problematické částí podařilo zoptimalizovat a nástroj tak, dle mého názoru, splnil cíle stanovené na počátku vývoje. Aplikace byla navrhnuta s ohledem na možná rozšíření, kterých se nabízí celá řada, nejzásadnějším z nich je podpora práce s více SŘBD, než je tomu doposud. Za další užitečná rozšíření považuji návrhář pohledů, možnost práce v offline režimu nebo export do formátů, které podporují další nástroje v této oblasti.

Téma bakalářské práce pro mne bylo velice přínosné, protože jsem se díky němu naučil pracovat s mnoha technologiemi v oblasti vývoje aplikací pro platformu Microsoft Windows. Díky této práci jsem nabyl nové znalosti také v oblasti správy databázových systémů a využití návrhových vzorů v rámci návrhu a implementace rozsáhlejší aplikace.

\newpage
% TODO: Zkontrolovat zdroje
\begin{thebibliography}{99}
	\bibitem{chenERD} CHEN, Peter Pin-Shan. \textit{The entity-relationship model---toward a unified view of data. ACM Transactions on Database Systems} [online]. 1(1), 9-36 [cit. 2017-03-10]. Dostupné z: \url{http://dspace.mit.edu/bitstream/handle/1721.1/47432/entityrelationshx00chen.pdf}
	
	\bibitem{dbVsb} KRÁTKÝ, Michal a Radim BAČA. \textit{Databazové systémy} [online]. [cit. 2017-03-11]. Dostupné z: \url{http://dbedu.cs.vsb.cz/SubPages/OpenFile.aspx?file=book/dbcb.pdf}
	
	\bibitem{compErNotations} SONG, Il-Yeol, Mary EVANS a E.K. PARK. \textit{A Comparative Analysis of Entity-Relationship Diagrams} [online]. [cit. 2017-03-11]. Dostupné z: \url{http://www.cci.drexel.edu/faculty/song/publications/p_Jcse-erd.PDF}
	
	\bibitem{bachmanDsd} BACHMAN, C. W. \textit{Data structure diagrams} [online]. [cit. 2017-03-11]. Dostupné z: \url{http://www.minet.uni-jena.de/dbis/lehre/ws2005/dbs1/Bachman-DataStructureDiagrams.pdf}
	
	\bibitem{wikiDsd} Data structure diagram. In: \textit{Wikipedia: the free encyclopedia} [online]. San Francisco (CA): Wikimedia Foundation, 2001- [cit. 2017-03-11]. Dostupné z: \url{https://en.wikipedia.org/wiki/Data_structure_diagram}
	
	\bibitem{whatIsERD}Lucidchart. \textit{What is an Entity Relationship Diagram} [online]. [cit. 2017-03-10]. Dostupné z: \url{https://www.lucidchart.com/pages/er-diagrams}
	
	\bibitem{erdSymbols}Lucidchart. \textit{ER Diagram Symbols and Notation} [online]. [cit. 2017-03-10]. Dostupné z: \url{https://www.lucidchart.com/pages/ER-diagram-symbols-and-meaning}
	
	\bibitem{aStar}Amit’s A* Pages. \textit{Pathfinding} [online]. [cit. 2017-03-21]. Dostupné z: \url{http://theory.stanford.edu/~amitp/GameProgramming/}
	
	\bibitem{queue}Visual Studio Magazine. \textit{Priority Queues with C\#} [online]. [cit. 2017-04-06]. Dostupné z: \url{https://visualstudiomagazine.com/Articles/2012/11/01/Priority-Queues-with-C.aspx}
	
	\bibitem{wpf}Microsoft. \textit{Introduction to WPF in Visual Studio 2015} [online]. [cit. 2017-04-07]. Dostupné z: \url{https://msdn.microsoft.com/en-us/library/aa970268.aspx}
	
	\bibitem{mvvm}Microsoft. \textit{Developer's Guide to Microsoft Prism Library 5.0 for WPF} [online]. [cit. 2017-04-07]. Dostupné z: \url{https://msdn.microsoft.com/en-us/library/gg406140.aspx}
\end{thebibliography}


\appendix
% TODO: Struktura media
\section{Struktura přiloženého optického média}
\begin{table}[h!]
	\centering
	\caption{Obsah optického média}
	\begin{tabular}{l l}
		\toprule
		Adresář & Obsah \\
		\midrule
		\textbackslash src & Projekt s aplikací ve Visual Studiu 2015 \\
		\textbackslash bp & PDF soubor s textem bakalářské práce \\
		\textbackslash setup & Instalační soubory aplikace \\
		\midrule
	\end{tabular}
\end{table}

\section{Použité knihovny třetích stran}
\begin{itemize}
	\item MahApps.Metro - \url{https://github.com/MahApps/MahApps.Metro}
	\item Extended WPF Toolkit Community Edition - \url{http://wpftoolkit.codeplex.com/}
\end{itemize}

\section{Testované CASE nástroje a SŘBD zmíněné v textu} \label{secAddCase}
\begin{table}[h!]
	\centering
	\caption{Stávající CASE nástroje}
	\label{tab:case}
	\begin{tabular}{|p{4cm} | p{4cm} | p{6cm} |}
		\hline
		Název & Výrobce & Oficiální web \\ \hline
		Oracle SQL Developer Data Modeler & Oracle Corporation & \url{http://www.oracle.com/technetwork/developer-tools/datamodeler/overview/index.html} \\ \hline
		Toad Data Modeler & Quest Software & \url{https://www.quest.com/products/toad-data-modeler/} \\ \hline
		SQL Server Management Studio & Microsoft & \url{https://www.microsoft.com/en-us/sql-server/default.aspx} \\ \hline
		Visual Paradigm & Visual Paradigm International & \url{https://www.visual-paradigm.com/} \\ \hline
		StarUML 2 & MKLab & \url{http://staruml.io/} \\
		\hline
	\end{tabular}
\end{table}

\begin{table}[h!]
	\centering
	\caption{Zmíněné SŘBD}
	\label{tab:dbms}
	\begin{tabular}{|p{4cm} | p{4cm} | p{6cm} |}
		\hline
		Název & Výrobce & Oficiální web \\
		\hline
		Oracle Database & Oracle Corporation & \url{https://www.oracle.com/database/} \\ \hline
		Microsoft SQL Server & Microsoft & \url{https://www.microsoft.com/en-us/sql-server/default.aspx} \\ \hline
		DB2 & IBM & \url{https://www.ibm.com/analytics/us/en/technology/db2/} \\ \hline
		PostgreSQL & The PostgreSQL Global Development Group & \url{https://www.postgresql.org/} \\ \hline
		MySQL & Oracle Corporation & \url{https://www.mysql.com/} \\
		\hline
	\end{tabular}
\end{table}

\end{document}